{"meta":{"title":"马俊昌的个人博客","subtitle":"念念不忘，必有回想。","description":"路虽远，不行不至，事虽难，不做不成。","author":"马俊昌","url":"https://majunchang.github.io"},"pages":[{"title":"关于我","date":"2017-12-17T14:04:13.000Z","updated":"2018-10-23T07:38:16.000Z","comments":true,"path":"about/index.html","permalink":"https://majunchang.github.io/about/index.html","excerpt":"","text":"关于我姓名： 马俊昌微信： 13012270529 16619713158邮箱： 13012270529@163.com junchang.ma@ele.meQQ： &nbsp;2471978285@qq.comgithub： &nbsp;&nbsp;https://github.com/majunchang个人简介：一枚小小的前端程序猿，web前端和nodejs的忠实粉丝。兴趣爱好：电子发烧友，喜欢音乐，看书，打球，吉他。热爱生活享受生活。工作状态：目前就职于饿了么星选（原百度外卖）"},{"title":"categories","date":"2017-12-17T05:26:02.000Z","updated":"2017-12-17T05:26:35.000Z","comments":true,"path":"categories/index.html","permalink":"https://majunchang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-17T05:13:57.000Z","updated":"2018-01-14T06:03:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://majunchang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"详解js原型，构造函数以及class之间的原型关系","slug":"详解js原型，构造函数以及class之间的原型关系","date":"2018-10-11T14:47:27.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"详解js原型，构造函数以及class之间的原型关系/","link":"","permalink":"https://majunchang.github.io/详解js原型，构造函数以及class之间的原型关系/","excerpt":"","text":"原型概念在构造函数创建的时候，系统默认的帮构造函数创建并关联一个对象 这个对象就是原型作用在原型中的所有属性和方法，都可以被和其关联的构造函数创建出来的所有的对象共享访问原型构造函数名.prototype 实例化的对象.proto原型的简单使用利用对象的动态特性为原型对象增加成员直接替换原型对象（jq核心方法的实现 就是使用原型替换的思想）12345678910111213141516function Person (name) &#123; this.name = name &#125; Person.prototype.fn = function () &#123; console.log('hello world') console.log(this.name) &#125; var p = new Person('小红') p.fn() p.name = '晓丽' p.fn() console.log(Person.prototype) console.log(p)1. prototype含义： 是一个函数的属性，这个属性是一个指针，指向一个对象作用： 构造函数调用 访问该构造函数所关联的原型对象2. proto含义： 是一个对象拥有的内置属性，是js内部使用寻找原型链的属性，通过该属性可以允许实例对象直接访问到原型3. constructor含义：原型对象的constructor 指向其构造函数,如果替换了原型对象之后，这个constructor属性就不准确，需要手动补充一下原型链构造函数以及js原生Object对象之间的原型关系原型的注意事项当对象在访问属性和方法的时候，会现在自身查找，如果没有才回去原型中找。（一级一级传递 形成了原型链）替换原型对象的时候，替换之前构造函数创建的对象A和替换之后创建的对象B，A和B的原型是不一致的。对象能够访问的原型，就是在对象创建的那一刻，和构造函数关联的那个原型扩展以及延伸构造函数在很多编程语言中，如java，objectC,c++等，都存在类的概念，类中有私有属性，私有方法等，通过类来实现面对对象的继承，但是，在ES5以及以前中不像上面这几种语言一样，有严格的类的概念。js通过构造函数以及原型链来实现继承。特点首字母必须为大写，用来区分普通函数内部使用的this对象，来指向即将要生成的实例对象使用new 关键字来生成实例对象（下面为new关键字的具体实现）12345var obj = new Date()// 可以分解为var obj = &#123;&#125;;obj.__proto__ = Date.prototype;Base.call(obj)缺点所有的实例对象都可以继承构造器函数中的属性和方法，但是同一个对象实例之间，无法共享属性。如果方法在构造函数内部，每次new一个实例对象的时候，都会创建内部的这些方法，并且不同的实例对象之间，不能共享这些方法，造成了资源的浪费（于是有了原型这个概念）实现方式 （简单列举几种）构造函数模式（自定义构造函数）构造函数与普通函数的区别12345678910111213141516171819202122//构造函数function Egperson (name,age) &#123; this.name = name; this.age = age; this.sayName = function () &#123; alert(this.name); &#125;&#125;var person = new Egperson('mike','18'); //this--&gt;personperson.sayName(); //'mike'//普通函数function egPerson (name,age) &#123; this.name = name; this.age = age; this.sayName = function () &#123; alert(this.name); &#125;&#125;egPerson('alice','23'); //this--&gt;windowwindow.sayName(); //'alice'工厂模式12345678910function CreatePerson(name, age, gender)&#123; var obj = &#123;&#125;; obj.name = name; obj.age = age; obj.gender = gender; //由于是函数调用模式，所以this打印出来是window console.log(this); return obj;&#125;var p = CreatePerson(\"小明\", 18, \"male\"); // 调用方式是函数的调用方式寄生模式12345678910function CreatePerson(name, age, gender)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.gender = gender; //这里的this指向new 创建出来的对象 console.log(this); return obj;&#125;var p = new CreatePerson(&quot;小明&quot;, 18, &quot;male&quot;); // 调用方式是函数的调用方式动态原型模式1234567891011121314151617181920212223242526272829function Person(name, age, job) &#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if(typeof this.sayName != \"function\") &#123; //所有的公有方法都在这里定义 Person.prototype.sayName = function() &#123; alert(this.name); &#125;； Person.prototype.sayJob = function() &#123; alert(this.job); &#125;; Person.prototype.sayAge = function() &#123; alert(this.age); &#125;; &#125;&#125;var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.sayName(); //Nicholasperson2.sayName(); //Gregjs实现继承的方式: 混入式继承，原型继承以及经典继承，ES6的Class也可以实现继承Class 详解基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。123456789101112131415161718192021222324// ES5function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2);// ES6//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;特点class中的constructor函数相当于ES5中的构造函数（声明属性以及静态方法，这种类创建属性和创建方法参照上面动态原型模式的构造函数。个人感觉有很多相似之处类中定义方法的时候，前面不加function，后面不加，可被实例对象也就是子类继承的方法 定义在类的prototype属性中。类的内部定义的所有方法都是不可枚举的类和模块内部默认采用严格模式子类继承父类以后，必须在constructor中调用时super方法，否则不能新建实例，因为子类没有属于自己的this对象，而是继承了父类的this对象对其进行加工类中的原型链关系每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。子类的proto属性，表示构造函数的继承，总是指向父类。子类prototype属性的proto属性，表示实例方法的继承，总是指向父类的prototype属性。12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true类的继承内部实现123456789101112131415161718class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B();Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125;作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。123Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype;实例的 proto 属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, &apos;red&apos;);p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true类中this指向问题类的方法内部含有this，默认指向类的实例。但是当类中的实例方法提取出来使用的时候，this指向运行时所在环境。解决方法（新版react中，在声明绑定方法的时候 三种方式与此相同）1234567891011121314151617class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125;class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125;ES5与ES6 实现继承的区别在ES5中，继承实质上是子类先创建属于自己的this，然后再将父类的方法添加到this（也就是使用Parent.apply(this)的方式而在ES6中，则是先创建父类的实例对象this，然后再用子类的构造函数修改this。","categories":[],"tags":[]},{"title":"React创建组件以及组件通信方式","slug":"React创建组件以及组件通信方式","date":"2018-10-11T14:42:44.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"React创建组件以及组件通信方式/","link":"","permalink":"https://majunchang.github.io/React创建组件以及组件通信方式/","excerpt":"","text":"无状态函数式组件创建纯展示组件，无法使用State，也无法使用组件的生命周期方法，只负责根据传入的props来展示，不涉及到要state状态的操作，是一个只带有一个render方法的组件类创建形式：123456789101112import React from 'react'function NoStatusComp (props) &#123; console.log(props) return ( &lt;div&gt; &lt;h1&gt;我是无状态组件&lt;/h1&gt; &lt;/div&gt; )&#125;export default NoStatusComp特点：不需要声明类，组件不会被实例化，整体渲染性能得到提升不需要显示声明this关键字，也就是说组件不能访问this对象不支持’ref’，同时也无法访问生命周期的方法无状态组件也是官方比较推荐的一种方式, 使得代码结构更加清晰，减少代码冗余，在开发过程中，尽量使用无状态组件。React.createClass方式创建组件createClass本质上是一个工厂函数,是ES5的原生的JavaScript来实现的React组件,是是react最初推荐的创建组件的方式。123456789101112131415161718192021222324252627282930313233343536import React from 'react'import &#123;Button&#125; from 'antd'let createClassComp = React.createClass(&#123; getInitialState () &#123; return &#123; text: 'React早期创建组件的方式', title: '教师节快乐，感谢生命中出现过的老师，让似水年华没有苍白，教会我们听说读写思', num: 0 &#125; &#125;, componentDidMount () &#123; console.log('cmd') console.log(this.props) &#125;, componentWillReceiveProps (nextProps) &#123; console.log(this.props) console.log('下一次') console.log(nextProps) &#125;, add () &#123; this.num++ &#125;, render () &#123; let &#123;title, text&#125; = this.state return ( &lt;div&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;span&gt;&#123;text&#125;&lt;/span&gt; &lt;Button onClick=&#123;this.add&#125;&gt; 触发方法 &lt;/Button&gt; &lt;/div&gt; ) &#125;&#125;)export default createClassComp新版的react 是16.4.1的 已经不再支持这种写法了特点：React.createClass会自绑定函数方法导致不必要的性能开销React.createClass的mixins不够自然、直观附一篇文章 介绍的比较详细 在此不做赘述了关于React.createClass方法与class App extends Component方法的区别React.Component创建组件React.Component是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，其成员函数不会自动绑定this，需要手动绑定，否则this不能获取当前组件实例对象。12345678910111213141516171819import React from 'react'import &#123; Button &#125; from 'antd'export default class ExtendsComp extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; data: props.data &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;h1&gt;我是新版创建组件的方法&lt;/h1&gt; &lt;Button&gt; 点我回去&lt;/Button&gt; &lt;/div&gt; ) &#125;&#125;特点:其成员函数不会自动绑定this，需要手动绑定，否则this不能获取当前组件实例对象, 绑定this 有三种方法 比较推荐在构造函数中绑定类的constructor需要接收props并且调用super(props)。这是createClass所没有的一点。在调用super之后，可以直接设置state。react的组件更新react的父组件 更新的时候 触发了render方法父组件下面的所有子组件都被重新渲染可以通过使用immutatble的这种数据结构 去节省这种渲染（只渲染数据改动的子组件 数据没有改动的 维持原状）Immutable 常用API简介Immutable 详解及 React 中实践react组件的通信方式父组件传递给子组件React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息123456789101112131415import React, &#123; Component &#125; from &apos;react&apos;;import Child from &apos;./Child&apos;;class Parent extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Child name=&quot;apple&quot; /&gt; &lt;/div&gt; ); &#125;&#125;export default Parent;子组件传递给父组件将父组件的方法 通过props传递给子组件 然后子组件调用方法 （也就是调用了父组件的方法 进而发生改变）123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;class List3 extends Component &#123; static propTypes = &#123; hideConponent: PropTypes.func.isRequired, &#125; render() &#123; return ( &lt;div&gt; 我是字组件 &lt;button onClick=&#123;this.props.show&#125;&gt;点我 展示&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default List3;较深层级的父子组件通信层层组件传递props （不推荐）使用contextcontext是一个全局变量,像是一个大容器,在任何地方都可以访问到,我们可以把要通信的信息放在context上,然后在其他组件中可以随意取到;官方说明：Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。在一个典型的 React 应用中，数据是通过 props 属性由上向下（由父及子）的进行传递的，但这对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI主题），这是应用程序中许多组件都所需要的。 Context 提供了一种在组件之间共享此类值的方式，而不必通过组件树的每个层级显式地传递 propsparent.jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react'import Child from './childOneComp'import ChildTwoComp from './childTwoComp'import PropTypes from 'prop-types';class Parent extends Component &#123; constructor () &#123; super() this.state = &#123; listArr: [ &#123; text: '题目一' &#125;, &#123; text: '题目二' &#125; ] &#125; &#125; // 提供一个函数,用来返回相应的context对象 getChildContext () &#123; return &#123; color: 'red' &#125; &#125; // 父组件声明自己支持context static childContextTypes = &#123; color: PropTypes.string, &#125; render () &#123; let &#123;listArr&#125; = this.state return ( &lt;div&gt; &lt;Child name='Sara' /&gt; &#123; listArr.map((item, index) =&gt; &#123; return &lt;ChildTwoComp value=&#123;item.text&#125; key=&#123;index&#125; /&gt; &#125;) &#125; &lt;/div&gt; ) &#125;&#125;export default Parentchild.jsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';import emitter from '../../utils/event'class ChildTwoComp extends Component &#123; // 子组件声明自己要使用context static contextTypes = &#123; color: PropTypes.string, &#125; static propTypes = &#123; value: PropTypes.string, &#125; constructor()&#123; super() this.state =&#123; color:'pink' &#125; &#125; componentDidMount() &#123; this.eventEmitter = emitter.addListener('colorChange', (color) =&gt; &#123; console.log('接受了方法'); this.setState(&#123; color, &#125;,()=&gt;&#123; console.log(color); &#125;); &#125;); &#125; componentWillUnmount() &#123; if(typeof this.eventEmitter === 'function')&#123; this.eventEmitter.removeListener(this.eventEmitter); &#125; &#125; render() &#123; const &#123; value &#125; = this.props; return ( &lt;div&gt; &lt;h1 style=&#123;&#123; background: this.state.color &#125;&#125;&gt;1234567&lt;/h1&gt; &lt;li style=&#123;&#123; background: this.context.color &#125;&#125;&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;/li&gt; &lt;/div&gt; ); &#125;&#125;export default ChildTwoComp;兄弟组件之间通信以常用的发布/订阅模式举例,借用Node.js Events模块的浏览器版实现要求组件A的数据 传递给组件B 但是 组件A和组件B 必须要同时渲染的时候 才能使用这种方法（有些类似vue的eventBus的功能，但是没有vue的强大）child.js123456789101112131415161718192021222324252627import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;import emitter from &apos;../../utils/event&apos;import &#123; Button &#125; from &apos;antd&apos;export default class Child extends React.Component &#123; constructor (props) &#123; super(props) this.changeColor = this.changeColor.bind(this) &#125; changeColor () &#123; emitter.emit(&apos;colorChange&apos;, &apos;deepskyblue&apos;) &#125; render () &#123; let &#123;name&#125; = this.props return ( &lt;div&gt; &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt; &lt;Button onClick=&#123;this.changeColor&#125;&gt; 11111点我回去&lt;/Button&gt; &lt;/div&gt; ) &#125;&#125;Child.propTypes = &#123; name: PropTypes.string.isRequired&#125;event.js123import &#123; EventEmitter &#125; from 'events'export default new EventEmitter()react组件通信的第三方库pubsub 类似于发布订阅模式这样redux （比较推荐）","categories":[],"tags":[]},{"title":"前端构造桌面级应用（QQ音乐）","slug":"前端构造桌面级应用（QQ音乐）","date":"2018-08-21T14:40:46.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"前端构造桌面级应用（QQ音乐）/","link":"","permalink":"https://majunchang.github.io/前端构造桌面级应用（QQ音乐）/","excerpt":"","text":"前端构造桌面级音乐播放器（nw与electron）最近研究前端如何构造桌面级应用，看了一下nw和ecectron。于是自己使用vue写了一个pc版本的qq音乐播放器。由于时间太紧，做的功能很有限。但是本片文章主要是介绍nw与electron这两个工具。前端的代码已经开源，感兴趣的同学可以自己下载下来，添加一些比较有趣的功能以及进行代码的优化项目预览图分为首页、歌手列表页、歌手详情页、排行榜。排行榜详情页以及播放器页面，排行榜与歌手页基本一致 不做赘述首页歌手列表页歌手详情页歌手搜索功能播放器页面技术栈前端 vue、vue-router、webpack后端（代理） node+express做代理接口转发 jsonp axios打包工具 electron electron-packager项目简介1. 数据获取部分1数据主要是获取QQ音乐的接口，有得接口jsonp的方式 就可以获取到数据 有得接口需要使用Node做一下代理 来解决跨域2. 代理转发12在开发阶段，我们可以使用vue中的dev模块中的proxyTable进行路径的重写和代理的转发在build的时候 我们可以手动配置 访问路径 或者使用express做一下配置 类似于我们将代码 放入nginx服务器中那样3. 项目注意事项123我们需要在node启动的服务器里面（也就是本地服务器中）解决跨域问题使用nw的时候需要解决不能播放音频的问题index.html以及静态资源的这些路径问题4. 项目优化点123项目的css部分可以优化 优化为less，sass 或者cssmodule这样项目的组件可以抽离一下 目前排行榜详情页以及歌手详情页基本上的逻辑是一样的 可以进行抽使用组件化 也可以使用 slot项目中 还可以新增很多功能 比如说播放mv 下载歌曲 以及添加我喜欢的音乐等NodeJs+Express的代理A 使用express 去访问打包完成之后的dist目录的静态资源B 为了解决 当dist文件拖入nw打开 或者 直接打开dist目录的index.html 以及使用electron打包之后 的接口访问跨域问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import path from 'path'import express from 'express'import axios from 'axios'import &#123;join&#125; from 'path'const app = express()// 挂载静态路径// Aapp.use(express.static(join(__dirname, '../../dist')))let router = express.Router()// Brouter.all('*', function (req, res, next) &#123; // res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'Content-Type,Content-Length, Authorization, Accept,X-Requested-With') res.header('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS') res.header('X-Powered-By', ' 3.2.1') next()&#125;)// 做代理的分发和请求 分类歌单router.get('/getDiscList', function (req, res) &#123; var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg' axios.get(url, &#123; headers: &#123; referer: 'https://c.y.qq.com/', host: 'c.y.qq.com' &#125;, params: req.query &#125;).then((response) =&gt; &#123; console.log('接口响应成功') res.json(response.data) &#125;).catch((e) =&gt; &#123; console.log(e) &#125;)&#125;)router.get('/lyric', function (req, res) &#123; var url = 'https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg' axios.get(url, &#123; headers: &#123; referer: 'https://c.y.qq.com/', host: 'c.y.qq.com' &#125;, params: req.query &#125;).then((response) =&gt; &#123; // 由于response 是一个jsonp格式的 所以我们要对这个 进行json转化 var result = response.data var regExe = /^\\w+\\((&#123;[^()]+&#125;)\\)$/ var matchArr = result.match(regExe) if (matchArr) &#123; res.json(JSON.parse(matchArr[1])) &#125; &#125;).catch((e) =&gt; &#123; console.log(e) &#125;)&#125;)app.use('/api', router)app.listen(3000, () =&gt; &#123; console.log('服务器已经启动,监听的端口号是3000')&#125;)​nw（node-weikit的简介与使用）node-webkit的简介官网需要翻墙 下载需要翻墙 （唉…… 在这里贴一下nw的官网首页和下载截图）Github上nw.js有两万多Star和接近3000的Fork，说明它已经相当成熟。 并且在Github项目的最后面，显示Intel有赞助这个项目，看起来很牛的样子nw.js也是一个使用前端技术（html、css、JavaScript）来构建pc端程序的一个框架。可以兼容windows xp系统支持用HTML5, CSS3, JS和WebGL来写应用程序，包括桌面端和移动端；完全支持Node.js APIs和所有的第三方模块；性能也不会很差，对于轻量级的应用足够了；对应用进行打包和发布十分简单，也就是说写一份代码很容易移植到不同的平台（包括主流的Linux, Mac OS X 和 Windows）；nw能做什么？nw.js就是使HTML, CSS, JavaScript写的原本在浏览器上运行的程序，也可以在桌面端运行。nw的安装与使用下载安装包安装（建议大家下载带有开发包的 便于调试）官网下载nw.app的压缩包 解压以后即可使用附官网地址: https://github.com/nwjs/nw.js1效果图：使用命令行安装 （命令行下载比较慢 所以不是特别建议）1sudo npm install -g nwnw的打包流程打包工具 （简单介绍几种 ）nodebob是node-webkit的构建工具，可以在Windows环境中自动发布node-webkit应用程序。目前在v0.1中，用windows批处理脚本编写。nw-builder＆grunt-nw-builder允许您使用grunt为mac，win和linux构建node-webkit应用程序。他们将下载特定版本的预构建二进制文件，解压缩它，创建一个版本文件夹，为指定目录创建app.nw文件，并将app.nw文件复制到它所属的位置Nuwk！Nuwk！可以轻松地基于node-webkit创建Mac应用程序，从而简化测试和构建过程。它负责创建可执行文件，附加应用程序图标并相应地配置plist文件。（非常alpha阶段）generator-node-webkit是一个yeoman生成器，用于开发node-webkit应用程序并为mac，linux和win创建包。松集成到您的构建过程中，它将为Linux，Windows和OSX下载nwjs 32 / 64bit，并从给定的源目录为所有3个平台构建软件包。windows下的打包流程https://www.cnblogs.com/tinyphp/p/5052327.htmlmac/osx下的打包流程https://blog.csdn.net/weichuang_1/article/details/48849335https://blog.csdn.net/baidu_30907803/article/details/78795405nw解决不能播放音频问题MP3编码属于专利编码，非开源授权的，所以在nw.js中默认不支持MP3的播放，需要手动启用才行。需要从社区中下载对应版本的libffmpeg.dll文件 然后将原来的替换一下即可解决社区地址: https://github.com/iteufel/nwjs-ffmpeg-prebuilt/releases目标文件地址： /Users/baidu/Desktop/nwjs-sdk-v0.31.1-osx-x64/nwjs.app/Contents/Versions/67.0.3396.79我把这个软件安装在了桌面上 这是目标地址 大家只要记住后面的就行,Versions后面的数字 代表的nw内嵌的谷歌版本（不一样也没事）nw的使用以及如何调试通过快捷键 option+command+i 打开内置谷歌的控制台。如果不能打开 或没反应 有可能是大家下载的版本 不是带开发工具的nw的应用nwjs——你值得拥有！不得不提nw.js开发出的应用已经涵盖了许多领域：WhatsApp 经典的聊天应用，还有Messenger；Powder Player 种子下载，以及视频播放器；Boson Editor 代码编辑器，甚至还有一款Markdown编辑器叫Story-writer；Leanote Desktop App 类似Evernote的笔记类应用程序；Mongo Management Studio 数据库管理应用。electron（简介与使用）官网地址 （不用翻墙 这一点很棒）https://electronjs.org/简介electron 是一个可以让我们使用js创建桌面应用程序的框架，并且可以很简单的实现跨平台，让我们可以更轻松的书写业务逻辑，而不用担心跨平台的问题。与nw相比，electron的使用人数更多，文档更加齐全，使用起来也更加方便。社区很强大,基本上你遇到的问题 都可以在社区中解决。官方示例12345678# 克隆示例项目的仓库$ git clone https://github.com/electron/electron-quick-start# 进入这个仓库$ cd electron-quick-start# 安装依赖并运行$ npm install &amp;&amp; npm start项目截图electron的安装与打包工具的安装全局安装electron1npm install electron -g本地安装1npm install electron --save-dev打包工具这里的打包工具我选择的是electron-packager在项目中 安装打包工具 然后配置一下命令行1npm install --save-dev electron-packager​1234567891011121314151617181920212223242526272829&#123; \"name\": \"qq-music\", \"version\": \"1.0.0\", \"description\": \"A Vue.js project\", \"author\": \"junchang.ma.ele_waimai &lt;junchang.ma@ele.me&gt;\", \"private\": true, \"scripts\": &#123; \"dev\": \"webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js\", \"start\": \"npm run dev\", \"build\": \"node build/build.js\", \"electron_dev\": \"electron build/electron.js\", \"electron_build\": \"electron-packager ./dist/ --platform=darwin --arch=x64 --overwrite\" &#125;, \"dependencies\": &#123; .... &#125;, \"devDependencies\": &#123; ... &#125;, \"engines\": &#123; \"node\": \"&gt;= 6.0.0\", \"npm\": \"&gt;= 3.0.0\" &#125;, \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ]&#125;说一下命令行配置：1packager\": \"electron-packager ./app HelloWorld --all --out ./OutApp --version 1.4.0 --overwrite --icon=./app/img/icon/icon.ico\"​location of project：项目所在路径name of project：打包的项目名字platform：确定了你要构建哪个平台的应用（Windows、Mac 还是 Linux） win32=&gt; windows下 darwin=&gt; macarchitecture：决定了使用 x86 还是 x64 还是两个架构都用electron version：electron 的版本optional options：可选选项字段里的 项目名字，version，icon路径要改成自己的；electron的打包（将electron集成在vue中）命令行配置 参考上面本地预览模式在build文件夹下 生成一个electron.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Modules to control application life and create native browser windowconst &#123;app, BrowserWindow&#125; = require('electron')// import path from 'path'const path = require('path')// Keep a global reference of the window object, if you don't, the window will// be closed automatically when the JavaScript object is garbage collected.let mainWindowfunction createWindow () &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123;width: 800, height: 600&#125;) // and load the index.html of the app. mainWindow.loadFile(path.join(__dirname, '../dist/index.html')) // Open the DevTools. // mainWindow.webContents.openDevTools() // Emitted when the window is closed. mainWindow.on('closed', function () &#123; // Dereference the window object, usually you would store windows // in an array if your app supports multi windows, this is the time // when you should delete the corresponding element. mainWindow = null &#125;)&#125;// This method will be called when Electron has finished// initialization and is ready to create browser windows.// Some APIs can only be used after this event occurs.app.on('ready', createWindow)// Quit when all windows are closed.app.on('window-all-closed', function () &#123; // On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', function () &#123; // On OS X it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (mainWindow === null) &#123; createWindow() &#125;&#125;)// In this file you can include the rest of your app's specific main process// code. You can also put them in separate files and require them here.​打包模式将build目录的下electron.js 复制到dist文件中一份配置一个package.json12345&#123; \"name\": \"nw-qqMusic\", 项目名称 \"version\": \"0.0.1\", 版本号 \"main\": \"electron.js\" 项目入口文件&#125;在项目根目录的命令行中 运行12npm run build npm run electron_buildNw与Electron的对比nw.js无论从表面还是本质都更接近 Node.js，nw.js直接继承和使用了node.js的启动、开发、运行方式，对node.js的修改最小，而 electron的改动很大，增加了很多自己的东西，使用起来感觉与node.js差别明显。nw.js是和node.js一样是单进程的，electron改成了双进程，技术实现改变。electron的优点：开源的核心扩展比较容易，界面定制性强，原则上只要是Web能做的他都能做。是目前最廉价的跨平台技术方案，相对其他跨平台方案（如 QT GTK+ 等），更稳定，bug少， 毕竟只要浏览器外壳跑起来了，里面的问题不会太多 。electron的缺点：卡，启动慢，这可能是webkit的锅。毕竟一个浏览器要支持的功能确实有点多。除了主进程 你可能还需要启动一些辅助进程来完成工作。而每当你新开一个进程，起步价就是一个nodejs的内存开销！丢帧，这个最严重，可我已习惯了native 的丝滑. mac下感觉还可以 win下有点够呛。打出来的包太大。（很显然，即便是一个空包，也至少包含了一个浏览器的体积NW.js对库的整合更深，某种意义上说，对chromium和Node有更深入的理解（新功能要用，必须把源码拿来build进去）。从license上来看，Electron是Github的，NW.js则是Intel。nw 在mac上只能构建mac的应用 ，windows下只能构建windows的。而electron 可以通过命令行构建不同环境下的 linux mac和windows等资料文档qq音乐接口获取方式的相关文档https://blog.csdn.net/xiayiye5/article/details/79487560https://blog.csdn.net/hhzzcc_/article/details/79769386https://segmentfault.com/a/1190000007685830nw相关资料https://github.com/nwjs/nw.jshttps://blog.csdn.net/tsyccnh/article/details/54782835electron的相关资料打造你的第一个electron应用github地址常用打包工具Electron: 从零开始写一个记事本appelectron打包：electron-packager及electron-builder两种方式实现（for Windows）electron-packager命令常用参数大全探索与思考​ 实现让div的高度也自适应的方式 和宽度始终成一个比例，能有几种实现方法？如果我们买一个自己的服务器 发布一些软件 部署后端代码，这样能赚钱嘛？（比如 我之前说的小型商户管理系统？）项目地址与启动方式123456789101112131415161718克隆项目地址 git clone https://github.com/majunchang/QQ-music.git安装依赖 npm i cd nodeServernpm i启动Node代理 在nodeServer文件夹下npm run dev 本地预览 （项目的根目录下）npm run dev 本地electron预览npm run electron_dev打包编译npm run build npm run electron_build","categories":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/tags/vue/"}]},{"title":"miniredux的实现与源码解析","slug":"miniredux的实现与源码解析","date":"2018-07-16T13:07:06.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"miniredux的实现与源码解析/","link":"","permalink":"https://majunchang.github.io/miniredux的实现与源码解析/","excerpt":"","text":"本文主要介绍redux的react-redux的原理redux原理github地址：https://github.com/majunchang/miniRedux总体流程图！！！原生react的调用和常用方法react流程图展示redux中有一个reducer函数和action 通过dispatch(action)来触发reducer的对应的case提供一个createStore方法 传入reducer 返回的对象中包含getState和subscribe和dispatch方法调用示例：redux 原生版的调用 getState()获取状态 subscribe()进行监听 dispatch()触发相应的action 改变state123456789101112131415161718192021222324252627282930313233import &#123; createStore &#125; from './woniuRedux/woniuRedux'// 这就是reducer处理函数，参数是状态和新的actionexport function counter (state = 0, action) &#123; // let state = state||0 console.log(action) console.log(state) switch (action.type) &#123; case '加苹果': return state + 1 case '吃苹果': return state - 1 default: return 10 &#125;&#125;const store = createStore(counter)// console.logconst init = store.getState()console.log(`一开始有$&#123;init&#125;个苹果`)function listener () &#123; const current = store.getState() console.log(`现在有$&#123;current&#125;个苹果`)&#125;// 订阅，每次state修改，都会执行listenerstore.subscribe(listener)// 提交状态变更的申请store.dispatch(&#123; type: '加苹果' &#125;)store.dispatch(&#123; type: '加苹果' &#125;)store.dispatch(&#123; type: '加苹果' &#125;)store.dispatch(&#123; type: '吃苹果' &#125;)store.dispatch(&#123; type: '吃苹果' &#125;)redux实现原理（源码解析）（简易版）主要介绍createStore applyMiddleware和bindActionCreatorscaeateStore 源码解读12345678910111213141516171819202122232425262728293031export function createStore (reducer, enhancer) &#123; if (enhancer) &#123; console.log('enhancer', enhancer) ① return enhancer(createStore)(reducer) // return applymiddleware(thunk)(createStore)(reducer) &#125; let currentState = &#123;&#125; let currentListeners = [] function getState () &#123; return currentState &#125; function subscribe (listener) &#123; currentListeners.push(listener) &#125; function dispatch (action) &#123; currentState = reducer(currentState, action) currentListeners.forEach(v =&gt; &#123; v() &#125;) return action &#125; // 初次调用的时候 首先执行一次 dispatch dispatch(&#123;type: '@@redux/firstTime'&#125;) return &#123;getState, subscribe, dispatch&#125;&#125;createStore 内部是一个观察者模式， subscribe 添加注册函数 dispatch让函数自调用首次调用createStore的时候 内部会执行一次dispatch 将reducer绑定进来enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。123456enhancer ƒ (createStore) &#123; return function () &#123; var _console, _console2; for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) &#123; args[_key2] = argum…普及一下高阶函数高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 高阶组件 思想function hello() &#123; console.log('我喜欢react');&#125;function WrapperHello(fn) &#123; return function () &#123; console.log('before hello'); fn() console.log('after hello'); &#125;&#125;var hello = WrapperHello(hello);hello() 属性代理class Hello extends React.Component &#123; render() &#123; return &lt;h2&gt;高阶组件的参数组件&lt;/h2&gt; &#125;&#125;function wrapperHello(Comp) &#123; class WrapComp extends React.Component &#123; render() &#123; return (&lt;div&gt; &lt;p&gt;这是hoc高阶组件特有的元素&lt;/p&gt; &lt;Comp &#123;...this.props&#125;&gt;&lt;/Comp&gt; &lt;/div&gt;) &#125; &#125; return WrapComp&#125; 反向继承function wrapperHello(Comp) &#123; class WrapComp extends Comp&#123; componentDidMount()&#123; console.log('高阶组件新增的生命周期，加载完成'); &#125; render()&#123; return &lt;Comp&gt;&lt;/Comp&gt; &#125; &#125; return WrapComp&#125;Hello = wrapperHello(Hello);applyMiddleware源码解读12345678910111213141516171819202122232425262728// 中间件机制export function applyMiddleware (...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; console.log(args) // 这里的...args指的是解耦之后的renducer 在这里 指的就是counter console.log(...args) const store = createStore(...args) let dispatch = store.dispatch let midApi = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // 单个中间件的情况 // dispatch = middleware(midApi)(store.dispatch) // dispatch = middware(midApi)(stroe.dispatch)(action) // 多个中间件的情况 console.log(store) // =&gt; store 就是一个对象 里面包含dispatch getState和subscribe等方法 console.log('middles', middlewares) let middlewareChain = middlewares.map(middleware =&gt; middleware(midApi)) // 返回的这个dispatch 就执行过了所有的中间件 带有了中间件的功能 dispatch = compose(...middlewareChain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125;compose函数源码123456789101112131415161718192021function compose (...fns) &#123; if (fns.length === 0) &#123; return args =&gt; args &#125; if (fns.length === 1) &#123; return fns[0] &#125; // return fns.reduce((ret, item) =&gt; (...args) =&gt; ret(item(...args))) return fns.reduce((ret, item) =&gt; (...args) =&gt; &#123; console.log('当有多个参数的时候') // ...args ==&gt;&gt; store.dispatch的这个方法 item和ret指代不同的中间件 /* //假设 middleChain = [a,b,c] dispatch = compose(...middlewareChain)(store.dispatch) = compose(a,b,c)(store.dispatch) // 那么这个函数在compose中 就被拆解为 dispatch = compose(a(b(c)))(store.dispatch) */ return ret(item(...args)) &#125;)&#125;结合中间件的源码来看 我们这里以thunk举例thunk中最开始接受的参数 {dispatch getState} 是从midApi中传来的next 指代store.dispatch action就是action12345678910const thunk = (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; // 如上面所示 return action(dispatch, getState) &#125; // 默认情况下 return next(action)&#125;export default thunkbindActionCreators 源码解读官网用法 ： http://www.redux.org.cn/docs/api/bindActionCreators.html1234567891011121314151617181920212223242526// 工具函数 这个函数的作用是为了让creator函数里面的参数进行透传/* addGun(参数) dispatch(addGun(参数)) */function bindActionCreator (creator, dispatch) &#123; return (...args) =&gt; dispatch(creator(...args))&#125;// bindActionCreators// &#123;addGun, removeGun, addGunAsync&#125; 就是形式参数 creatorsexport function bindActionCreators (creators, dispatch) &#123; let bound = &#123;&#125; Object.keys(creators).forEach((fnKey, index) =&gt; &#123; let creator = creators[fnKey] bound[fnKey] = bindActionCreator(creator, dispatch) &#125;) return bound /* 还可以采用另外一种写法 return Object.keys(creators).reduce((ret,item)=&gt;&#123; ret[item] = bindActionCreator(creators[item],dispatch) return ret &#125;,&#123;&#125;) */&#125; mini-react-redux的实现原理和源码解读","categories":[{"name":"React","slug":"React","permalink":"https://majunchang.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://majunchang.github.io/tags/React/"}]},{"title":"react-redux常用api详解","slug":"redux常用api详解","date":"2018-07-09T15:10:55.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"redux常用api详解/","link":"","permalink":"https://majunchang.github.io/redux常用api详解/","excerpt":"","text":"createStore(reducer, [preloadedState], enhancer)创建一个 Redux store 来以存放应用中所有的 state。应用中应有且仅有一个 store。参数：reducer (Function): 接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。[preloadedState] (any): 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 combineReducers 创建 reducer，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 reducer 可理解的内容。enhancer (Function): Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。返回值保存了应用中所有state的对象，改变state的唯一方法是dispatch action。 你也可以subscribe监听state的变化 然后更新uicreateStore的简易版源码enhancer是一个高阶函数 运行结果表明 enhancer之后代码 直接进入applymiddleware1const store = createStore(counter, applyMiddleware(thunk, arrThunk))12345678910111213141516171819202122232425262728293031export function createStore (reducer, enhancer) &#123; if (enhancer) &#123; console.log('enhancer', enhancer) return enhancer(createStore)(reducer) // return applymiddleware(thunk)(createStore)(reducer) &#125; let currentState = &#123;&#125; let currentListeners = [] function getState () &#123; return currentState &#125; function subscribe (listener) &#123; currentListeners.push(listener) &#125; function dispatch (action) &#123; currentState = reducer(currentState, action) currentListeners.forEach(v =&gt; &#123; v() &#125;) return action &#125; // 初次调用的时候 首先执行一次 dispatch dispatch(&#123;type: '@@redux/firstTime'&#125;) return &#123;getState, subscribe, dispatch&#125;&#125;StoreStore 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。Store 不是类。它只是有几个方法的对象。 要创建它，只需要把根部的 reducing 函数 传递给 createStore。注意Store的方法getState() 返回应用当前的state树dispatch(action) 分发action 这是触发state变化的唯一途径subscribe(listener) 添加一个变化监听器 每当dispatch(action)的时候 就会执行 state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。123456789101112131415161718192021const createStoreWithMiddleware = applyMiddleware(...middlewares)(createStore)const store = createStoreWithMiddleware(rootReducer)sagaMiddleware.run(rootSaga)const action = type =&gt; store.dispatch(&#123; type &#125;)function render () &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; action('INCREMENT')&#125; onDecrement=&#123;() =&gt; action('DECREMENT')&#125; onIncrementAsync=&#123;() =&gt; action('INCREMENT_ASYNC')&#125; /&gt;, document.getElementById('root') )&#125;render()store.subscribe(render)applyMiddleware(…middlewares)使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。redux-thunk 举例例如，redux-thunk 支持 dispatch function，以此让 action creator 控制反转。被 dispatch 的 function 会接收 dispatch 作为参数，并且可以异步调用它。这类的 function 就称为 thunk。12345678910111213141516function addIfOdd() &#123; return (dispatch, getState) =&gt; &#123; const currentValue = getState(); if (currentValue % 2 == 0) &#123; return false; &#125; dispatch(add()) &#125;&#125;function addAsy(delay = 2000) &#123; return (dispatch, getState) =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(add()) &#125;, delay) &#125;&#125;applymiddleware 源码解析官方源码1234567891011121314151617181920212223242526272829303132function applyMiddleware() &#123; //1 for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) &#123; middlewares[_key] = arguments[_key]; &#125; //2 return function (createStore) &#123; //3 return function (reducer, preloadedState, enhancer) &#123; //4 var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; //5 var middlewareAPI = &#123; getState: store.getState, dispatch: function dispatch(action) &#123; return _dispatch(action); &#125; &#125;; chain = middlewares.map(function (middleware) &#123; return middleware(middlewareAPI); &#125;); //6 _dispatch = _compose2[&apos;default&apos;].apply(undefined, chain)(store.dispatch); return _extends(&#123;&#125;, store, &#123; dispatch: _dispatch &#125;); &#125;; &#125;;&#125;简化版源码12345678910111213141516171819202122232425262728export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; // 生成一个store const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] //简陋版的store，里面包含了`getState`和`dispatch`两个方法。 const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; //将middlewareAPI作为参数注入到每个middleware中去，执行middleware, 返回一个新的链。 //中间件函数(store)=&gt;next=&gt;action. // chain [next=&gt;action,...]; //这个 next 其实store.dispatch. 而`action`就是`dispatch`的action chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) //我们假设有三个中间件,fn1,fn2,fn3,那么下面代码等同于 dispatch=fn1(fn2(fn3(store.dispatch))); //可以发现，中间件所组成的dispatch 其实就是一个执行过fn1,fn2,fn3的函数。 //所以，每个中间件在遇到不是自己处理范围之内的action的时候，会使用next(action)，将其传递给下一个中间件。 dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125;搭配一个redux-thunk的源码12345678910const thunk = (&#123;dispatch, getState&#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; // 如上面所示 return action(dispatch, getState) &#125; // 默认情况下 return next(action)&#125;export default thunkappliymiddleware的总结1createStore(reducer,initState,applyMiddleware(ThunkMiddleware));1createStore(reducer,applyMiddleware(ThunkMiddleware));这两种设置中间件的方式是一致的1const store = applyMiddleware(...middlewares)(createStore)(reducer, initialState)。1const store = createStore(reducer, initialState, applyMiddleware(...middlewares))compose的作用从右到左来组合多个函数。这是函数式编程中的方法，为了方便，被放到了 Redux 里。当需要把多个 store 增强器 依次执行的时候，需要用到它。附示例代码：1234const store = createStore(reducers, compose( applyMiddleware(thunk), window.devToolsExtension ? window.devToolsExtension() : f =&gt; f))compose的源码解析123456789function compose (...fns) &#123; if (fns.length === 0) &#123; return args =&gt; args &#125; if (fns.length === 1) &#123; return fns[0] &#125; return fns.reduce((ret, item) =&gt; (...args) =&gt; ret(item(...args)))&#125;附 reduce方法reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。reduce() 对于空数组是不会执行回调函数的参数123456array.reduce(function(total, currentValue, currentIndex, arr), initialValue) total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 initialValue 可选 代表total的初始类型和初始值基本使用123456var arr = [1,2,3,4,5,6] var result = arr.reduce((sum,val)=&gt;&#123; return sum+val &#125;,100) console.log(result);高级使用如何知道一串字符串中每个字母出现的次数？123456var arrString = 'abcdaabc';arrString.split('').reduce(function(res, cur) &#123; res[cur] ? res[cur] ++ : res[cur] = 1 return res;&#125;, &#123;&#125;)","categories":[{"name":"React","slug":"React","permalink":"https://majunchang.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://majunchang.github.io/tags/React/"}]},{"title":"react全家桶 NodeJS MongoDB搭建实时聊天的app","slug":"react全家桶-NodeJS-MongoDB搭建实时聊天的app","date":"2018-07-09T14:23:40.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"react全家桶-NodeJS-MongoDB搭建实时聊天的app/","link":"","permalink":"https://majunchang.github.io/react全家桶-NodeJS-MongoDB搭建实时聊天的app/","excerpt":"","text":"👉 GitHub: https://github.com/majunchang/reachChatApp基于==React(16.x)== 全家桶制作的一款实时聊天app，采用组件化，模块化的开发方式，用到了==react-redux==等插件，使用==antd-mobile==的ui框架。技术栈【前端】React: 用于搭建用户界面的javascript库，特点是声明式渲染和组件化开发Redux: Redux 是 JavaScript 状态容器，提供可预测化的状态管理。让你构建一致化的应用，运行与不同的环境，并且易于测试。React-redux: 核心在于provieder，connect和中间件机制。React-router:是一个基于 React 之上的强大路由库，它可以让你向应用中快速地添加视图和数据流，同时保持页面与 URL 间的同步。【后端】NodeJs:使用 express 构建一个本地 HTTP server 来调试 React 项目MongoDB: 存储用户数据和聊天数据的非关系型数据库Express: Node的基于 Node.js 平台，快速、开放、极简的 web 开发框架。【自动化构建】create-react-app: 官网提供的react脚手架工具，快速初始化项目代码eslint： 代码风格检查工具，规范代码书写技术详解react中注意的地点绑定事件，state和actions的映射，路由包含的switch等登录和注册部分（以登录举例）首先发送一个接口请求后端，检测是否有用户信息。没有的话 直接跳转到登录页登录这里 对输入的用户名和密码做一下校验 然后存储到本地一个用户id登录返回成功之后dispatch返回数据 触发reducer 将数据存储到state中主页以及切换部分头部和底部使用共有部分，中间的内容使用数组中循环渲染不同的Route登录成功之后，有了redirect选项，并且我们在Login中，设置了路由的跳转12&#123;this.props.redirectTo &amp;&amp; this.props.redirectTo !== '/login' ? &lt;Redirect to=&#123;this.props.redirectTo&#125;&gt;&lt;/Redirect&gt; : null&#125;我们在这些子组件中 使用@connect方法, 将redux中的state和action传递进来聊天数据的展示主要是使用socket.io 实现数据通信原理后端使用express+socketio的结合，前端监听端口号9000以后，进行了数据的交互和接收我们在每条数据上 加上了其他的一些值 形成一个对象。根据发收方的用户id 进行辨别和数组的循环渲染未读消息的更新默认每条数据的read字段 都是false，筛选聊天数据的发送对象是正在使用这个软件的用的时候，筛选出来的结果就是未读消息的数量socket 使用emit触发 on来接受 当接受到一个消息的时候 未读消息加1当我们从聊天页面退出的时候 把这个聊天界面的对方的id发送给后端进行处理 将总体未读消息数量 减去这个id的维度消息数量预览效果快速开始开发版1234567891011// 开启mongodb数据库服务// 将项目地址完整的clone下来 git clone https://github.com/majunchang/reachChatApp// 进入到项目文件夹 安装相关依赖 cd reatChatApp npm install// 进行本地编译 npm start// 进入到server文件夹里面 启动nodejs服务 建议使用nodemon启动 node（ndoemon） server生产版12345678910// 开启mongodb数据库服务// 将项目地址完整的clone下来 git clone https://github.com/majunchang/reachChatApp// 进入到项目文件夹 安装相关依赖 cd reatChatApp npm install// 首先将项目进行打包 然后启动打包的端口（server.js)中已经配置 npm run build// 完成之后 npm run server","categories":[{"name":"React","slug":"React","permalink":"https://majunchang.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://majunchang.github.io/tags/React/"}]},{"title":"回流和重绘","slug":"回流和重绘","date":"2018-03-05T14:02:51.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"回流和重绘/","link":"","permalink":"https://majunchang.github.io/回流和重绘/","excerpt":"","text":"我们要明确页面在文档加载完成之后到完全显示中间的过程是根据文档生成DOM树（包括display:none的节点）在DOM树基础上根据节点的几何属性（margin/padding/width/height等)生成render树（不包括display:none、head节点但会包含visibility:hidden节点）在render树基础上进行进一步渲染包括color,outline等样式reflow:当render树中的一部分或者全部因为大小边距等问题发生改变而需要重建的过程叫做回流repaint:当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘回流一定会引发重绘 但是 重绘不一定引发回流引发回流的情况 ：首当其冲自然是dom树结构变化，比如你删除或者添加某个node.元素几何属性变化，包括margin,padding,height,width,border等页面渲染初始化获取某些属性。虽然浏览器引擎可能会针对重排做了优化，比如Opera，它会等到有足够 数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了render树的直接变化，当获取一些属性时，浏览器为取得 正确的值也会触发回流。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。（这段我是直接引用的。。。）浏览器窗口发生变化-resize事件发生时12345678var s = document.body.style;s.padding = &quot;2px&quot;; // 回流+重绘s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘s.color = &quot;blue&quot;; // 再一次重绘s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode(&apos;abc!&apos;));说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/tags/javascript/"}]},{"title":"vue双向绑定原理","slug":"vue双向绑定原理","date":"2018-03-05T13:51:42.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"vue双向绑定原理/","link":"","permalink":"https://majunchang.github.io/vue双向绑定原理/","excerpt":"","text":"本文采用了比较特殊的input和v-model指令 实际上vue的指令解析模板很复杂，本文重点是理解数据更新的思想几种实现双向绑定的做法目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。实现数据绑定的做法有大致如下几种：发布者-订阅者模式（backbone.js）脏值检查（angular.js）数据劫持（vue.js）发布者-订阅者模式:一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)，这里有篇文章讲的比较详细，有兴趣可点这里这种方式现在毕竟太low了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式脏值检查:angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：DOM事件，譬如用户输入文本，点击按钮等。( ng-click )XHR响应事件 ( $http )浏览器Location变更事件 ( $location )Timer事件( $timeout , $interval )执行 $digest() 或 $apply()数据劫持:vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。思路整理实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图入口函数，整合以上三者流程图数据监听器1234567891011121314151617181920212223242526272829303132333435363738394041function observe(obj, vm) &#123; // 对传入的对象 遍历 并分别添加 object.defineProperty Object.keys(obj).forEach((key) =&gt; &#123; defineReactive(vm, key, obj[key]) &#125;) &#125; function defineReactive(vm, key, val) &#123; var dep = new Dep(); Object.defineProperty(vm, key, &#123; get: function () &#123; // 通过这一步 添加订阅者 if (Dep.target) dep.addSub(Dep.target) return val; &#125;, set: function (newval) &#123; if (newval === val) return val = newval; // 通知订阅者 dep.notify() &#125; &#125;) &#125; // 需要实现一个消息订阅器 function Dep() &#123; // 消息订阅的让容器是一个数组 数组的每一项 都是指代一个view和mode的中间者 this.subs = [] &#125; Dep.prototype = &#123; addSub: function (sub) &#123; this.subs.push(sub) &#125;, notify: function () &#123; this.subs.forEach((sub) =&gt; &#123; // 在这里 需要配合watcher进行更新 sub.update() &#125;) &#125; &#125;实现Compile1234567891011121314151617181920212223242526272829303132333435363738394041// 在这里增加dom编译模板 function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment(); var child; while (child = node.firstChild) &#123; compile(child, vm); // 将子节点劫持到文本节点中 flag.appendChild(child) &#125; return flag &#125; function compile(node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 跟据节点类型去判断 if (node.nodeType === 1) &#123; var attr = node.attributes; for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName === 'v-model') &#123; // 此时 name为text var name = attr[i].nodeValue; // 增加数据的变化监听 node.addEventListener('input', (e) =&gt; &#123; vm[name] = e.target.value; &#125;) ; // 在这里 因为 我们的数据监听器 已经封装了vm[name] 触发了 getter方法 完成了数据的初始化 node.value = vm[name]; node.removeAttribute('v-model') &#125; &#125; new Watcher(vm, node, name, 'input') &#125; if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1; name = name.trim(); new Watcher(vm, node, name, 'text') &#125; &#125; &#125;增加watcher 观察函数12345678910111213141516171819202122232425//订阅者 搭建数据监听变化和变异模板的桥梁 function Watcher(vm, node, name, nodeType) &#123; Dep.target = this; this.vm = vm; this.node = node; this.name = name; this.nodeType = nodeType this.update() Dep.target = null; &#125; Watcher.prototype = &#123; update: function () &#123; this.get() if (this.nodeType === 'text') &#123; this.node.nodeValue = this.value &#125; if (this.nodeType === 'input') &#123; this.node.value = this.value &#125; &#125;, get: function () &#123; this.value = this.vm[this.name]; &#125; &#125;入口函数123456789101112131415161718192021222324252627function Vue(options) &#123; // 将options里面的data属性 放入数据监听器 this.data = options.data; var data = this.data; observe(data, this); // this指代vm // 对指定id的dom 进行页面的渲染 this.$el = options.el; var id = this.$el; var Dom = nodeToFragment(document.getElementById(id), this); // 编译完成之后 将dom 添加到节点中 document.getElementById(id).appendChild(Dom) &#125; var vm = new Vue(&#123; el: 'app', data: &#123; text: 'hello world', name: '你好，全世界' &#125; &#125;); vm.data.text = 'majunchang' document.getElementsByClassName('btn')[0].onclick = function () &#123; vm.text = 'majunchang' vm.name = '又疑瑶台镜，飞在青云端' &#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/tags/vue/"}]},{"title":"hexo搭建个人博客","slug":"hexo搭建个人博客","date":"2018-03-04T13:33:40.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"hexo搭建个人博客/","link":"","permalink":"https://majunchang.github.io/hexo搭建个人博客/","excerpt":"个人总结hexo博客搭建流程以及常用命令","text":"个人总结hexo博客搭建流程以及常用命令大概流程：搭建 Node.js 环境搭建 Git 环境GitHub 注册和配置安装配置 Hexo关联 Hexo 与 GitHub PagesGitHub Pages 地址解析到个人域名Hexo 的常用操作搭建 Node.js 环境为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。在 Node.js 官网：https://nodejs.org/en/ 下载安装包 v6.10.3 LTS保持默认设置即可，一路Next，安装很快就结束了。然后打开命令提示符，输入 node -v、npm -v，出现版本号则说明 Node.js 环境配置成功，第一步完成！！！搭建 Git 环境为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在 Git 官网：https://git-scm.com/ 下载安装包 Git-2.13.0-64-bit.exe桌面右键，打开 Git Bush Here，输入 git –version，出现版本号则说明 Git 环境配置成功，第二步完成！！！GitHub 注册和配置GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。Github注册：https://github.com/创建仓库：Repository name 使用自己的用户名，仓库名规则：1yourname/yourname.github.io到此搭建 Hexo博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作安装配置 HexoHexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。强烈建议你花20分钟区读一读 Hexo 的官方文档：https://hexo.io/zh-cn/使用 npm 安装 Hexo：在命令行中输入1npm install hexo-cli -g然后你将会看到下图，可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。查看Hexo的版本1hexo version安装 Hexo 完成后，请执行下列命令来初始化 Hexo，用户名改成你的，Hexo 将会在指定文件夹中新建所需要的文件。1234hexo init majunchang.github.iocd majunchang.github.ionpm install新建完成后，指定文件夹的目录如下：1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等运行本地 Hexo 服务123hexo server或者hexo s您的网站会在 http://localhost:4000 下启动。如果 http://localhost:4000 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。注意1：执行hexo server提示找不到该指令解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：123sudo npm install hexo-server或者npm install hexo -server --save配置Git个人信息现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。12git config --global user.name &quot;majunchang&quot;git config --global user.email &quot;2471978285@qq.com&quot;配置 Deployment在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成你的：需要注意的是：冒号后面记得空一格！1234567// https 后面跟的是 git的用户名的密码 截止到@符号之前 所以密码中 不要包含@符号 否则会报错# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://majunchang:*****@github.com/majunchang/majunchang.github.io.git branch: master本地文件提交到 GitHub Pages12345678910// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo dHexo 的常用操作发表一篇文章123hexo new &quot;文章标题&quot;D:\\GitHub\\Hexo\\test&gt;hexo new &quot;文章标题&quot;INFO Created: D:\\GitHub\\Hexo\\test\\source\\_posts\\文章标题.md在本地博客文件夹 source_posts 文件夹下看到我们新建的 markdown 文件。当然，我们也可以手动添加Markdown文件在source-&gt;_deploy文件夹下，其效果同样可以媲美hexo new文章编辑好之后，运行生成、部署命令：123hexo cleanhexo ghexo d当然你也可以执行下面的命令，相当于上面两条命令的效果12hexo cleanhexo d -g文章如何添加多个标签有两种多标签格式123456tags: [a, b, c]或tags: - a - b - c更改主题官方主题库：https://hexo.io/themes/Hexo主题非常，推荐使用 Next 为主题，请阅读 Next 的官方文档（ http://theme-next.iissnan.com/ ），5 分钟快速安装。再提示一点，大家可以hexo主题修改一步就hexo s看下变化，初次接触对参数不清楚。只有hexo s后在可以在本地浏览到效果，Ctrl+C 停止服务器。添加插件添加 sitemap 和 feed 插件切换到你本地的 hexo 目 CIA ，在命令行窗口，输入以下命令123npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save修改 _config.yml，增加以下内容123456789101112# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml再执行以下命令，部署服务端1hexo d -g配完之后，就可以访问 https://majunchang.github.io/ ，发现这两个文件已经成功生成了。。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://majunchang.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://majunchang.github.io/tags/hexo/"}]},{"title":"vue总结","slug":"vue总结","date":"2018-03-04T13:31:58.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"vue总结/","link":"","permalink":"https://majunchang.github.io/vue总结/","excerpt":"","text":"vue使用总结心得vue的安装在这里我们主要针对的是vue的单页面项目 如果仅仅是为了单个案例可以直接下载 然后script安装Vue 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run devvue的生命周期vue的生命周期图示header 1header 2beforeCreate实例刚刚被创建 el和data并未初始化created实例创建完成 data被初始化 但是el没有被初始化 dom不存在beforeMount完成了el的初始化 模板编译之前mounted模板编译之后 完成挂载beforeUpdate组件更新之前uodated组件更新之后beforeDestory组件销毁前调用destoryed组件销毁后调用vue的核心思想（数据绑定和组件化）==vue的双向数据绑定==123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"text\"&gt; &#123;&#123; text &#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; /* 1 数据监听器 首先有一个数据监听的函数 目的是 监听数据的变化 拿到最新值 并通知订阅者 2 指令解析器 有一个编译的函数 对元素的节点进行扫描和解析 并绑定相关的更新函数 3 watcher 作为连接observe和compile的敲了 3 订阅者 这个订阅者 负责与watcher 配合收到属性变动的通知，执行相应的回调函数 完成视图的更新 */ function observe(obj, vm) &#123; // 对传入的对象 遍历 并分别添加 object.defineProperty Object.keys(obj).forEach((key) =&gt; &#123; defineReactive(vm, key, obj[key]) &#125;) &#125; function defineReactive(vm, key, val) &#123; var dep = new Dep(); Object.defineProperty(vm, key, &#123; get: function () &#123; // 通过这一步 添加订阅者 if (Dep.target) dep.addSub(Dep.target) return val; &#125;, set: function (newval) &#123; if (newval === val) return val = newval; // 通知订阅者 dep.notify() &#125; &#125;) &#125; // 需要实现一个消息订阅器 function Dep() &#123; // 消息订阅的让容器是一个数组 数组的每一项 都是指代一个view和mode的中间者 this.subs = [] &#125; Dep.prototype = &#123; addSub: function (sub) &#123; this.subs.push(sub) &#125;, notify: function () &#123; this.subs.forEach((sub) =&gt; &#123; // 在这里 需要配合watcher进行更新 sub.update() &#125;) &#125; &#125; // 在这里增加dom编译模板 function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment(); var child; while (child = node.firstChild) &#123; compile(child, vm); // 将子节点劫持到文本节点中 flag.appendChild(child) &#125; return flag &#125; function compile(node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 跟据节点类型去判断 if (node.nodeType === 1) &#123; var attr = node.attributes; for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName === 'v-model') &#123; // 此时 name为text var name = attr[i].nodeValue; // 增加数据的变化监听 node.addEventListener('input', (e) =&gt; &#123; vm[name] = e.target.value; &#125;); // 在这里 因为 我们的数据监听器 已经封装了vm[name] 触发了 getter方法 完成了数据的初始化 node.value = vm[name]; node.removeAttribute('v-model') &#125; &#125; new Watcher(vm, node, name, 'input') &#125; if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1; name = name.trim(); new Watcher(vm, node, name, 'text') &#125; &#125; &#125; //订阅者 搭建数据监听变化和变异模板的桥梁 function Watcher(vm, node, name, nodeType) &#123; Dep.target = this; this.vm = vm; this.node = node; this.name = name; this.nodeType = nodeType this.update() Dep.target = null; &#125; Watcher.prototype = &#123; update: function () &#123; this.get() if (this.nodeType === 'text') &#123; this.node.nodeValue = this.value &#125; if (this.nodeType === 'input') &#123; this.node.value = this.value &#125; &#125;, get: function () &#123; this.value = this.vm[this.name]; &#125; &#125; function Vue(options) &#123; // 将options里面的data属性 放入数据监听器 this.data = options.data; var data = this.data; observe(data, this); // this指代vm // 对指定id的dom 进行页面的渲染 this.$el = options.el; var id = this.$el; var Dom = nodeToFragment(document.getElementById(id), this); // 编译完成之后 将dom 添加到节点中 document.getElementById(id).appendChild(Dom) &#125; var vm = new Vue(&#123; el: 'app', data: &#123; text: 'hello,world' &#125; &#125;) vm.text = 'ma'&lt;/script&gt;组件化思想将实现页面的某一部分功能的结构，样式和逻辑封装为一个整体，使其高内聚，低耦合，达到分治和复用的目的1为了提高代码复用性，减少重复性的开发，我们就把相关的代码按照 template、style、script 拆分，封装成一个个的组件。组件可以扩展HTML 元素，封装可重用的 HTML 代码，我们可以将组件看作自定义的 HTML 元素。在 Vue 里面，每个封装好的组件可以看成一个个的 ViewModel。组件的执行顺序子组件先在父组件中的 components 中进行注册。父组件利用 Vue.component 注册到全局。当渲染父组件的时候，渲染到，会把子组件也渲染出来。vue的路由分发（vue-router）vue的路由分发主要是使用vue-router 本质来说 使用了哈希路径和浏览器的history（html5新增api）vue-router的安装和项目中的配置1npm install vue-router --savevue-router的官网123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 在main.js中这样配置 import Vue from 'vue'import App from './App'import router from './router'/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, template: '&lt;App/&gt;', components: &#123;App&#125;, methods: &#123; &#125;, created() &#123; &#125;,&#125;)// 在router文件夹下的index.js中 这样配置 import Vue from 'vue';import Router from 'vue-router';import dashboard from '../pages/dashboard/dashboard.vue';import index from '../pages/index.vue';//系统设置页面import systemSetting from '../components/systemSetting/systemSetting.vue'// 引入登录页import login from '../pages/auth/login/login.vue'//引入注册页import register from '../pages/auth/register/register.vue'Vue.use(Router)var router = new Router(&#123; routes: [ &#123; path: '/login', name: 'login', component: superTubeLogin, &#125;, &#123; path: '/register', name: 'register', component: register &#125;, &#123; path: '/', name: 'index', component: index, children: [ &#123; path: '/dashboard', name: 'dashboard', component: dashboard, &#125;, //系统设置的页面 &#123; path: '/systemSetting', name: 'systemSetting', component: systemSetting, &#125;, //工作组 //授权用户管理 &#123; path: '/boxUserManageAllow', name: 'boxUserManageAllow', component: boxUserManageAllow &#125;, ] &#125;, &#123; path: '*', component: notFoundComponent &#125; ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; // 这里写的逻辑 任何路由跳转之前都会执行&#125;)export default router我们可以使用vue-router做那些事配置路由分发设置路由重定向典型的应用场景有 做登录前的禁止跳转在用户访问不存在的页面的时候 跳转到自定义的404页面在组件中进行路由的跳转进行组件之间的传参123456789101112131415161718const router = new VueRouter(&#123; routes: [ &#123; // path: '/user/:userId', name: 'user', component: User &#125; ]&#125;)// 在组件中 应该这样写 router-link 在渲染时 会被转化为a标签&lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt;// 在vue的生命周期 或者 methods中 应该这样写 router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 关于如何使用query进行传递参数 这里给出了一个示例// http://blog.csdn.net/k491022087/article/details/70214664向路由组件传递propshttps://router.vuejs.org/zh-cn/essentials/passing-props.html根据路由元信息 设置组件的初始化或者区别组件设置过渡的动态效果路由信息对象https://router.vuejs.org/zh-cn/api/route-object.htmlvue-router的使用注意事项在组件中跳转的时候 和 获取路由元信息的时候12345678// 组件中跳转this.$router.push(&#123; name: page, params: &#123;id: 0, type: page, content: item.content, template: item.template&#125; &#125;) // 获取路由元信息 this.$route.params.apiId​监听路由变化12345wacth:&#123; '$route'(to, from) &#123; ..... &#125;,&#125;vue的复杂存储（vuex）vue通信项目中遇到的比较通用的问题（易错点）1 如何阻止冒泡和事件的默认行为2 多层数据的嵌套以及更改vue遍历好的数组之后 如何进行实时显示3 如果遇到跨域问题 如何解决4 如何减少文件压缩体积5 如何进行文件的打包","categories":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/tags/vue/"}]},{"title":"基于数据分析的图书管理系统","slug":"基于数据分析的图书管理系统","date":"2018-01-13T11:54:21.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"基于数据分析的图书管理系统/","link":"","permalink":"https://majunchang.github.io/基于数据分析的图书管理系统/","excerpt":"","text":"基于数据分析的图书管理系统(原创-全栈项目)基于Vue全家桶(2.x)+NodeJs+Express+MongoDB+ES6+iview制作的图书管理系统，通过该系统来学习当下最流行的大框架和技术，采用前后端分类的开发方式，Vue全家桶（2.x）全部涉及。图书馆项目地址-https://github.com/majunchang/node-library技术栈前端Vue: 用于构建用户界面的MVVM框架，它的核心是实时响应的双向数据绑定和组件系统vue-router: 为vue提供的路由系统，主要体现在路由的跳转，动效的过渡以及对于路由的限制等vuex: Vue的集中状态管理，在多个组件共享某些状态时非常便捷，降低了组件开发传递数据的复杂度axios： 基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用，该项目中前端所有请求都是通过axios来实现数据接收和页面渲染。ES6：ECMAScript的新一代语法，模块化，解构赋值，Promise，class等方法，使得开发变得更加简单。后端Node.js: 整个系统后端通过 Node.js 进行实现，通过 Express 框架实现后端的 REST 接口，并以 json 的形式进行输出，对于普通的post请求和文件上传类的post请求 使用body-parser中间件和formidable插件进行处理。数据库mongoDB: NoSQL数据库，使用mongoose进行数据库的连接和对于数据库的快速建模操作收获掌握了在项目中运用Vue全家桶解决各类问题。熟悉了vue父子组件之间数据的传递和交互，熟悉了不相关的组件之间如何进行行为的触发和传值掌握了如何在vue中 使用相关的ui框架和第三方插件熟悉了组件化、模块化的开发思维，体会到了前后端分类开发的好处加深了对nodejs和相关模块(path,nodemailer等)的理解和掌握掌握了nodejs+mongoose操作数据库的一套完整的增删改查方法，体会到了图形统计的作用。项目截图首页注册页忘记密码页首页图书总览页分类总览页添加书籍页借书列表页数据分析页个人信息页","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://majunchang.github.io/tags/nodejs/"},{"name":"mongodb","slug":"mongodb","permalink":"https://majunchang.github.io/tags/mongodb/"}]},{"title":"cookie和web存储的比较","slug":"cookie和web存储的比较","date":"2017-12-19T12:11:37.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"cookie和web存储的比较/","link":"","permalink":"https://majunchang.github.io/cookie和web存储的比较/","excerpt":"","text":"cookie基本概念cookie非常小，限制在4kb左右，很多浏览器都限制一个站点最多保存20个cookie。如果没有设置时间，则表示cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种被称为会话cookie，它会被保存在内存中。当设置了过期时间，浏览器会把cookie保存在硬盘中，关闭浏览器之后任然有效，直到超过设定的过期时间。设置和获取cookie的方法原生123456789101112131415// 使用js创建cookiedocument.cookie=&quot;username=John Doe&quot;;// 添加一个过期时间document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT&quot;;// 使用path 告诉浏览器cookie的路径document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/&quot;;//读取var x = document.cookie;// 修改 旧的值将会被覆盖document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/&quot;;// 删除 删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;封装12345678910111213141516171819function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toGMTString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;&#125;function getCookie(cname)&#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return &quot;&quot;;&#125;localStorage和sessionStorage优势扩展了cookie的4k限制，为了更大的容量存储而设计的，是在浏览器端存储的数据减少网络流量，快速的读取数据，性能较好，可以作为临时存储localStorage是永久性存储，而sessionStorage属于当会话结束的时候，就会被清空劣势本质上是对字符串的读取，内容较多的时候 会消耗内存，导致页面变卡，不能被爬虫抓取到三者的异同特性名称cookielocalStoragesessionStorage数据的声明周期可设置失效时间，默认是关闭浏览器后失效除非被清除，否则永久保存仅仅在当前会话下有效，关闭页面或者浏览器后会被清除存放的数据大小4k左右一般为5M一般为5M与服务端通信会在http头中携带，如果使用cookie保存过多数据会带来性能问题仅在浏览器端保存不参与服务器的通信仅在浏览器端保存不参与服务器的通信易用性需要自己封装有现成的api接口可以使用有现成的api接口可以使用","categories":[],"tags":[]},{"title":"windows下配置mongodb","slug":"如何在windows下配置mongodb数据库","date":"2017-10-10T15:32:47.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"如何在windows下配置mongodb数据库/","link":"","permalink":"https://majunchang.github.io/如何在windows下配置mongodb数据库/","excerpt":"","text":"如何在windows下配置mongodb数据库下载安装包官网下载链接 https://www.mongodb.com/download-center?jmp=nav#community下载以后进行解压 安装 （建议安装到c盘）如何启动和使用服务在mongodb的安装目录bin下 打开命令行 输入 ./mongod 将数据库服务启动起来 默认在27017端口然后 在该目录下 重新打开一个命令行 输出mongo 将数据库连接起来 就可以使用nodejs操作数据库了如何配置环境变量 使其可以在全局范围呢 打开1.2.3. 4.经过以上步骤配置环境变量 我们可以在任意文件夹（包括桌面）中 以mongod 和mongo 来启动和连接数据库服务了","categories":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/categories/javascript/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://majunchang.github.io/tags/mongodb/"}]},{"title":"Vue项目音乐app","slug":"网易云音乐","date":"2017-09-10T15:16:02.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"网易云音乐/","link":"","permalink":"https://majunchang.github.io/网易云音乐/","excerpt":"","text":"网易云音乐项目截图 准备工作我们使用 jsonp配合node代理 借用了qq音乐接口实现的 音乐播放器这是jsonp代码1234567891011121314151617181920212223242526272829303132333435/** * Created by majunchang on 2017/7/23. */import originJsonp from &apos;jsonp&apos;// 三个参数粉笔为 目标url 需要拼接在url上的参数 以及jsonp插件 需要的optionexport default function jsonp(url,paramdata,options) &#123; // 在这里引入一个 拼接字符串的方法 url += (url.indexOf(&apos;?&apos;)&lt; 0 ? &apos;?&apos;:&apos;&amp;&apos;)+param(paramdata); // 在这里返回一个Promise对象 return new Promise((resolve,reject)=&gt;&#123; // 在这里的data 跟上面的paramdata是不一样的 一个是 json的返回对象 一个是你传入的参数 originJsonp(url,options,(err,data)=&gt;&#123; if(!err)&#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;function param(paramdata) &#123; let url=&apos;&apos;; for(var k in paramdata)&#123; // 对参数对象里的每一项进行判断 let value = paramdata[k] == undefined ? &apos;&apos;: paramdata[k]; url+= `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; // 循环结束 url 拼接完毕 将其返回 return url&#125;这是配置接口的js12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by majunchang on 2017/7/23. */import jsonp from &apos;common/js/jsonp&apos;import &#123;commonParams,options&#125; from &apos;./config&apos;import axios from &apos;axios&apos;export function getRecommend() &#123; const url = &apos;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg&apos; const paramData = Object.assign(&#123;&#125;,commonParams,&#123; platform: &apos;h5&apos;, uin: 0, needNewCode: 1 &#125;) return jsonp(url,paramData,options)&#125;// 歌单列表export function getDiscList() &#123; const url=&apos;/api/getDiscList&apos;; // 需要拼接的数据 const data = Object.assign(&#123;&#125;,commonParams,&#123; platform: &apos;yqq&apos;, hostUin: 0, sin: 0, ein: 29, sortId: 5, needNewCode: 0, categoryId: 10000000, rnd: Math.random(), format: &apos;json&apos; &#125;) return axios.get(url,&#123; params:data &#125;).then((res)=&gt;&#123; console.log(res); return Promise.resolve(res.data); &#125;)&#125;这是nodejs 代码 仅仅推荐页面 用到了这个axios 其余的都是使用接口配置jsonp实现的12345678910111213141516171819var app = express()var apiRoutes = express.Router()apiRoutes.get(&apos;/getDiscList&apos;,function (req,res) &#123; var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;; axios.get(url,&#123; headers: &#123; referer: &apos;https://c.y.qq.com/&apos;, host: &apos;c.y.qq.com&apos; &#125;, params:req.query &#125;).then((response)=&gt;&#123; res.json(response.data) &#125;).catch((e)=&gt;&#123; console.log(e); &#125;)&#125;)app.use(&apos;/api&apos;,apiRoutes);推荐页面使用jsonp的方式 获取到数据轮播图部分https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg部分代码如下：1234567&lt;slider&gt; &lt;div v-for=&quot;item in recommends&quot;&gt; &lt;a :href=&quot;item.linkUrl&quot;&gt; &lt;img class=&quot;needsclick&quot; @load=&apos;loadImg&apos; :src=&quot;item.picUrl&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/slider&gt;1234567891011121314151617methods: &#123; _initScroll()&#123; console.log(this.listenScroll); if (!this.$refs.wrapper) &#123; return &#125; this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType, click: this.click &#125;) if(this.listenScroll)&#123; let _this = this; this.scroll.on(&apos;scroll&apos;,(pos)=&gt;&#123; _this.$emit(&apos;scroll&apos;,pos); &#125;) &#125; &#125;使用 better-scroll插件 将轮播图部分抽象成为一个组件 使用solt插槽 往里面填充内容使用插件的内容的相关api 和轮播组件里面的 props的 控制图片的轮播速度 间隔时间 和是否轮播 在此基础上 增加dots 也就是图片底部的圆点监听window的resize事件 当用户改变屏幕的时候 轮播效果不会发生改变访问连接 以及返回格式 数据歌单列表部分https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg由于qq音乐 对访问对象 做了限制 所以我们通过配置代理的方式 进行访问 npm run dev的时候 会在dev-server中运行 我们结合axios和express框架 配置使用代理加入loading组件和懒加载组件 在网速较低的情况下 提高了用户的体验后台代理代码12345678910111213141516171819var app = express()var apiRoutes = express.Router()apiRoutes.get(&apos;/getDiscList&apos;,function (req,res) &#123; var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;; axios.get(url,&#123; headers: &#123; referer: &apos;https://c.y.qq.com/&apos;, host: &apos;c.y.qq.com&apos; &#125;, params:req.query &#125;).then((response)=&gt;&#123; res.json(response.data) &#125;).catch((e)=&gt;&#123; console.log(e); &#125;)&#125;)app.use(&apos;/api&apos;,apiRoutes);歌手页面分为歌手列表页和歌手详情页 歌手列表页需要做出左右联动 类似于 手机通讯录那样的 歌手详情页要要出模拟原生app的 滑动感觉歌手列表页将他封装成了 一个 基本组件 我们需要实现以下功能滑动左边 右边的不同字母 要显示当相应的颜色点击右边的首字母 左右要滚动到响应的位置实现详解：子组件使用事件监听 scroll事件 然后触发父组件的方法 根据滑动距离（也就是y值）来跟高度数组作比较点击右边的首字母之后 触发父组件的点击事件 将高度数组的相应索引的值 赋给scrolly 然后使用watch 去监听这个值 最后调用better-scroll的方法 使页面滑动到相应的位置要配合移动端的touch事件 start move end 以及使用e.touches[0]相关的代码1234567891011121314151617181920212223onShortcutTouchStart(e)&#123; // 我们的目的是获取到 你触摸的这个的index索引值 let anchorIndex = getData(e.target, &apos;index&apos;); // js触摸事件 http://www.jianshu.com/p/832f36531df9 let firstTouch = e.touches[0]; this.touch.y1 = firstTouch.pageY; this.touch.anchorIndex1 = anchorIndex; this._scroll(anchorIndex) this.$refs.listView.scrollToElement(this.$refs.listGroup[anchorIndex], 0) &#125;, onShortcutTouchMove(e)&#123; let touchmove = e.touches[0]; this.touch.y2 = touchmove.pageY; let chazhi = (this.touch.y2 - this.touch.y1) / keyWordHeight | 0; this.touch.anchorIndex2 = parseInt(this.touch.anchorIndex1) + chazhi; // 使用滚动具体距离事件 this._scroll(this.touch.anchorIndex2) this.$refs.listView.scrollToElement(this.$refs.listGroup[this.touch.anchorIndex2], 0) &#125;, scroll(pos)&#123; this.scrollY = pos.y &#125;,歌手详情页技术实现难点：模拟原生移动应用实现 上滑和下滑的时候的效果更多的是在于如何使用css+scroll组件 实现这些效果123456789101112131415161718192021222324252627282930scrollY(newVal)&#123; // 在这里监听 scroll的变化 并改变头部图片的值 /* 我们要达到两个效果 第一个效果：歌单列表向上滑动的时候 遮罩层随着向上（有一个向上的最大距离） 往下滑的时候（图片要随着你下滑的距离 有一个放大的效果） */ let translateY = Math.max(this.minTransalteY, newVal); let scale = 1; let zIndex = 0; let blur = 0; const percent = Math.abs(newVal / this.imageHeight); if (newVal &gt; 0) &#123; scale = 1 + percent; zIndex = 10; &#125; else &#123; blur = Math.min(20, percent * 20) &#125; // 当列表向上滑动的时候 有一个高斯模糊的效果 this.$refs.layer.style[transform] = `translate3d(0,$&#123;translateY&#125;px,0)`; this.$refs.filter.style[backdrop] = `blur($&#123;blur&#125;px)` if (newVal &lt; this.minTransalteY) &#123; zIndex = 10; this.$refs.bgImage.style.height = `$&#123;leftHeigth&#125;px`; this.$refs.bgImage.style.paddingTop = 0; &#125; else &#123; this.$refs.bgImage.style.paddingTop = &apos;70%&apos; this.$refs.bgImage.style.height = 0 &#125; this.$refs.bgImage.style[transform] = `scale($&#123;scale&#125;)` this.$refs.bgImage.style.zIndex = zIndex &#125;播放详解music的获取，播放以及和vuex的联动原理详解1234graph TDA[api/singer/getSingerDetail方法获取到数据]--&gt;B(components/singer-detail使用构造函数,初始化songs数组)B--&gt;C(singer-datail-&gt;music-list-&gt;song-list 当我们点击歌曲之后 触发了actions 将歌曲列表和歌曲索引传递)C--&gt;D&#123; state中存储了歌手 播放 状态是否全屏等信息&#125;我们在 vuex中存储的信息 是为了我们在多个组件之中可以 获取到歌曲的状态 从而操作audio标签 来实现我们想要的功能歌曲播放界面—》 player.vue文件切换动效部分使用了贝塞尔曲线 唱片的旋转部分使用了 css的旋转特效对于歌词的解析部分使用了 插件lyric-parser https://github.com/ustbhuangyi/lyric-parser底部的圆圈 使用了svg 以及相关一些属性模拟进度排行页面排行页面与歌手页面非常相似 对于这样的基础组件 我们进行了复用 代码如下 文件是song—list 区别就是在排行页面中 我们点击的歌单 使用奖杯图片以及排名的12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=\"song-list\"&gt; &lt;ul&gt; &lt;li class='item' @click='selectItem(song,index)' v-for=\"(song,index) in songs\"&gt; &lt;div class=\"rank\" v-show='rank'&gt; &lt;span :class='getRankClass(index)' v-text='getRankText(index)'&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;h2 class=\"name\"&gt;&#123;&#123;song.name&#125;&#125;&lt;/h2&gt; &lt;p class=\"desc\"&gt;&#123;&#123;getDesc(song)&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; getRankClass(index)&#123; if (index &lt;= 2) &#123; return `icon icon$&#123;index&#125;` &#125; else &#123; return 'text' &#125; &#125;, getRankText(index)&#123; if (index &gt; 2) &#123; return index + 1 &#125; &#125;搜索页面有一个searchBox组件 充当搜索框 下面是一些热门搜索的标签 当我们进行搜索的时候 搜索结果 会复用scroll组件对于搜索框 也就是search-box的input进行截流处理123456789101112131415161718192021export function debounce(func,delay) &#123;let timer; return function(...args)&#123; // 这是es6的rest参数 if(timer)&#123; clearTimeout(timer); &#125; //console.log(args); timer = setTimeout(()=&gt;&#123; func.apply(this,args) &#125;,delay); &#125;&#125;// 在组件中的create钩子函数中 这样使用 created()&#123; this.$watch('inputMsg',debounce((newVal)=&gt;&#123; // console.log(newVal); this.$emit('inputMsg',newVal) &#125;,200)); &#125;,在搜索之后的建议中 点击 会对你点击的对象 也就是包括了歌手和歌曲的对象进行区别1234567891011121314151617181920selectItem(item) &#123; /* 判断为歌手的 选项 跳转路由 设置mumation 触发事件 */ if (item.type === TYPE_SINGER) &#123; // 构造一个singer实例 const singer = new Singer(&#123; id: item.singermid, name: item.singername &#125;) this.$router.push(&#123; path: `/search/$&#123;singer.id&#125;` &#125;) this.setSinger(singer); &#125; else &#123; this.insertSong(item) &#125; this.$emit('selected',item) &#125;,比较经典的方法封装jsonp方法1234567891011121314151617181920212223242526272829303132333435/** * Created by majunchang on 2017/7/23. */import originJsonp from 'jsonp'// 三个参数粉笔为 目标url 需要拼接在url上的参数 以及jsonp插件 需要的optionexport default function jsonp(url,paramdata,options) &#123; // 在这里引入一个 拼接字符串的方法 url += (url.indexOf('?')&lt; 0 ? '?':'&amp;')+param(paramdata); // 在这里返回一个Promise对象 return new Promise((resolve,reject)=&gt;&#123; // 在这里的data 跟上面的paramdata是不一样的 一个是 json的返回对象 一个是你传入的参数 originJsonp(url,options,(err,data)=&gt;&#123; if(!err)&#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;function param(paramdata) &#123; let url=''; for(var k in paramdata)&#123; // 对参数对象里的每一项进行判断 let value = paramdata[k] == undefined ? '': paramdata[k]; url+= `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; // 循环结束 url 拼接完毕 将其返回 return url&#125;混乱数组方法12345678910111213141516// 此处 添加一个 混乱数组的方法 将一个数组内部的元素 全部打乱function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1) + min)&#125;export function shuffle(arr) &#123; var arr1 = arr.slice(); for (var i = 0; i &lt; arr1.length; i++) &#123; var j = getRandomInt(0,i); var t = arr1[i]; arr1[i] = arr1[j]; arr1[j] = t; &#125; return arr1&#125;使用localstorage存储最近喜欢的1234567891011121314151617181920212223242526272829303132333435363738394041function insertArr(arr, val, compare, maxLen) &#123; var index = arr.findIndex(compare); if (index === 0) &#123; return &#125; else if (index &gt; 0) &#123; arr.splice(index, 1) &#125; arr.unshift(val) if (maxLen &amp;&amp; arr.length &gt; maxLen) &#123; arr.pop(); &#125;&#125;function deleteFromArray(arr, compare) &#123; const index = arr.findIndex(compare); if (index &gt; -1) &#123; arr.splice(index, 1); &#125;&#125;export function saveFavorite(songTarget) &#123; let songs = storage.get(favorite_key, []); insertArr(songs, songTarget, (item) =&gt; &#123; return item.id === songTarget.id; &#125;, favoriteMaxLen); storage.set(favorite_key, songs); return songs;&#125;export function deleteFavorite(song) &#123; let songs = storage.get(favorite_key, []) deleteFromArray(songs, (item) =&gt; &#123; return item.id === song.id &#125;) storage.set(favorite_key, songs) return songs&#125;export function loadFavorite() &#123; return storage.get(favorite_key, []);&#125;actions中在原先的歌曲列表中插入一首歌曲的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 声明一个actions 是我们在 suggest的时候 但歌曲列表被检索出来的时候 我们点击歌曲列表 进行播放的事件 为什么要这样做 因为用户在使用检索的时候 并不希望改变原先的歌曲列表 我们在播放完 检索的这首歌之后 循环的时候 依然是循环我们原先的播放数组 */export const insertSong = function (&#123;commit, state&#125;, song) &#123; let playlist = state.playlist.slice() let sequencelist = state.sequenceList.slice(); let currentIndex = state.currentIndex // 记录当前歌曲 // 查找当前播放列表中 是否存在 待插入的歌曲 并返回起索引 // 因为是插入歌曲 所以索引➕1 // 插入这首歌 到当前索引的位置 // 如果包含这首歌 // 如果插入的序号 大于列表中的序号 let currentSong = playlist[currentIndex]; let findPlayIndex = findIndex(playlist, song); currentIndex++; playlist.splice(currentIndex, 0, song); if (findPlayIndex &gt; -1) &#123; if (currentIndex &gt; findPlayIndex) &#123; playlist.splice(findPlayIndex, 1); currentIndex--; &#125; else &#123; playlist.splice(findPlayIndex + 1, 1); &#125; &#125; let currentSIndex = findIndex(sequencelist, song) + 1; let findSeqIndex = findIndex(sequencelist, song); sequencelist.splice(currentSIndex, 0, song); if (findSeqIndex &gt; -1) &#123; if (currentSIndex &gt; findSeqIndex) &#123; sequencelist.splice(findSeqIndex, 1); &#125; else &#123; sequencelist.splice(findSeqIndex + 1, 1); &#125; &#125; commit(types.SET_PLAYLIST, playlist) commit(types.SET_SEQUENCE_LIST, sequencelist) commit(types.SET_CURRENT_INDEX, currentIndex) commit(types.SET_FULL_SCREEN, true) commit(types.SET_PLAYING_STATE, true)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://majunchang.github.io/tags/vue/"}]},{"title":"javascript-this陷阱详解大全","slug":"javascript-this陷阱详解大全","date":"2017-06-05T08:55:10.000Z","updated":"2018-10-23T13:05:39.000Z","comments":true,"path":"javascript-this陷阱详解大全/","link":"","permalink":"https://majunchang.github.io/javascript-this陷阱详解大全/","excerpt":"","text":"JavaScript来自一门健全的语言，所以你可能觉得JavaScript中的this和其他面向对象的语言如java的this一样，是指存储在实例属性中的值。事实并非如此，在JavaScript中，最好把this当成哈利波特中的博格特的背包，有着深不可测的魔力。 下面的部分是我希望我的同事在使用JavaScript的this的时候应当知道的。内容很多，是我学习好几年总结出来的。 JavaScript中很多时候会用到this，下面详细介绍每一种情况。在这里我想首先介绍一下宿主环境这个概念。一门语言在运行的时候，需要一个环境，叫做宿主环境。对于JavaScript，宿主环境最常见的是web浏览器，浏览器提供了一个JavaScript运行的环境，这个环境里面，需要提供一些接口，好让JavaScript引擎能够和宿主环境对接。JavaScript引擎才是真正执行JavaScript代码的地方，常见的引擎有V8(目前最快JavaScript引擎、Google生产)、JavaScript core。JavaScript引擎主要做了下面几件事情：一套与宿主环境相联系的规则;JavaScript引擎内核（基本语法规范、逻辑、命令和算法);一组内置对象和API;其他约定。但是环境不是唯一的，也就是JavaScript不仅仅能够在浏览器里面跑，也能在其他提供了宿主环境的程序里面跑，最常见的就是nodejs。同样作为一个宿主环境，nodejs也有自己的JavaScript引擎–V8。根据官方的定义:Node.js is a platform built on Chrome’s JavaScript runtime for easily building fast, scalable network applicationsglobal this在浏览器里，在全局范围内，this等价于window对象。1231 &lt;script type=\"text/javascript\"&gt;2 console.log(this === window); //true3 &lt;/script&gt;在浏览器里，在全局范围内，用var声明一个变量和给this或者window添加属性是等价的。12 var foo = “bar”;3 console.log(this.foo); //logs “bar”4 console.log(window.foo); //logs “bar”5如果你在声明一个变量的时候没有使用var或者let(ECMAScript 6),你就是在给全局的this添加或者改变属性值。1 2 foo = “bar”; 3 4 function testThis() { 5 foo = “foo”; 6 } 7 8 console.log(this.foo); //logs “bar” 9 testThis();10 console.log(this.foo); //logs “foo”11在node环境里，如果使用REPL(Read-Eval-Print Loop，简称REPL:读取-求值-输出,是一个简单的，交互式的编程环境)来执行程序,this并不是最高级的命名空间，最高级的是global.this{ ArrayBuffer: [Function: ArrayBuffer],Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: 1 },Uint8Array: { [Function: Uint8Array] BYTES_PER_ELEMENT: 1 },…global === thistrue在node环境里，如果执行一个js脚本，在全局范围内，this以一个空对象开始作为最高级的命名空间，这个时候，它和global不是等价的。1 test.js脚本内容：23 console.log(this);4 console.log(this === global);56 REPL运行脚本：78 $ node test.js9 {}10 false在node环境里，在全局范围内，如果你用REPL执行一个脚本文件，用var声明一个变量并不会和在浏览器里面一样将这个变量添加给this。1 test.js:23 var foo = “bar”;4 console.log(this.foo);56 $ node test.js7 undefined但是如果你不是用REPL执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)1 &gt; var foo = “bar”;2 &gt; this.foo3 bar4 &gt; global.foo5 bar在node环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用var或者let，这个变量会自动添加到global对象，但是不会自动添加给this对象。如果是直接执行代码，则会同时添加给global和this1 test.js23 foo = “bar”;4 console.log(this.foo);5 console.log(global.foo);67 $ node test.js8 undefined9 bar上面的八种情况可能大家已经绕晕了，总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的。function this无论是在浏览器环境还是node环境， 除了在DOM事件处理程序里或者给出了thisArg(接下来会讲到)外，如果不是用new调用，在函数里面使用this都是指代全局范围的this。1 2 foo = “bar”; 3 4 function testThis() { 5 this.foo = “foo”; 6 } 7 8 console.log(this.foo); //logs “bar” 9 testThis();10 console.log(this.foo); //logs “foo”11test.jsfoo = “bar”;function testThis () {this.foo = “foo”;}console.log(global.foo);testThis();console.log(global.foo);$ node test.jsbarfoo除非你使用严格模式，这时候this就会变成undefined。1 2 foo = “bar”; 3 4 function testThis() { 5 “use strict”; 6 this.foo = “foo”; 7 } 8 9 console.log(this.foo); //logs “bar”10 testThis(); //Uncaught TypeError: Cannot set property ‘foo’ of undefined11如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系。1 2 foo = “bar”; 3 4 function testThis() { 5 this.foo = “foo”; 6 } 7 8 console.log(this.foo); //logs “bar” 9 new testThis();10 console.log(this.foo); //logs “bar”1112 console.log(new testThis().foo); //logs “foo”13我更喜欢把新的值称作一个实例。函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this，如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像。另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button。prototype this你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了。1 function Thing() {2 console.log(this.foo);3 }45 Thing.prototype.foo = “bar”;67 var thing = new Thing(); //logs “bar”8 console.log(thing.foo); //logs “bar”当你使用new为你的函数创建多个实例的时候，这些实例会共享你给prototype设定的值。对于下面的例子，当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo复制代码1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 console.log(this.foo);6 }7 Thing.prototype.setFoo = function (newFoo) {8 this.foo = newFoo;9 }1011 var thing1 = new Thing();12 var thing2 = new Thing();1314 thing1.logFoo(); //logs “bar”15 thing2.logFoo(); //logs “bar”1617 thing1.setFoo(“foo”);18 thing1.logFoo(); //logs “foo”;19 thing2.logFoo(); //logs “bar”;2021 thing2.foo = “foobar”;22 thing1.logFoo(); //logs “foo”;23 thing2.logFoo(); //logs “foobar”;实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 console.log(this.foo);6 }7 Thing.prototype.setFoo = function (newFoo) {8 this.foo = newFoo;9 }10 Thing.prototype.deleteFoo = function () {11 delete this.foo;12 }13 var thing = new Thing();14 thing.setFoo(“foo”);15 thing.logFoo(); //logs “foo”;16 thing.deleteFoo();17 thing.logFoo(); //logs “bar”;18 thing.foo = “foobar”;19 thing.logFoo(); //logs “foobar”;20 delete thing.foo;21 thing.logFoo(); //logs “bar”;或者你也能直接通过引用函数对象的prototype 来获得你需要的值。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 console.log(this.foo, Thing.prototype.foo);6 }78 var thing = new Thing();9 thing.foo = “foo”;10 thing.logFoo(); //logs “foo bar”;通过一个函数创建的实例会共享这个函数的prototype属性的值，如果你给这个函数的prototype赋值一个Array，那么所有的实例都会共享这个Array，除非你在实例里面重写了这个Array，这种情况下，函数的prototype的Array就会被隐藏掉。1 function Thing() {2 }3 Thing.prototype.things = [];456 var thing1 = new Thing();7 var thing2 = new Thing();8 thing1.things.push(“foo”);9 console.log(thing2.things); //logs [“foo”]给一个函数的prototype赋值一个Array通常是一个错误的做法。如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建。1 function Thing() {2 this.things = [];3 }456 var thing1 = new Thing();7 var thing2 = new Thing();8 thing1.things.push(“foo”);9 console.log(thing1.things); //logs [“foo”]10 console.log(thing2.things); //logs []实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值。1 function Thing1() {2 }3 Thing1.prototype.foo = “bar”;45 function Thing2() {6 }7 Thing2.prototype = new Thing1();8910 var thing = new Thing2();11 console.log(thing.foo); //logs “bar”一些人利用原型链的特性来在JavaScript模仿经典的面向对象的继承方式。任何给用于构建原型链的函数的this的赋值的语句都会隐藏原型链上游的相同的属性。1 function Thing1() {2 }3 Thing1.prototype.foo = “bar”;45 function Thing2() {6 this.foo = “foo”;7 }8 Thing2.prototype = new Thing1();910 function Thing3() {11 }12 Thing3.prototype = new Thing2();131415 var thing = new Thing3();16 console.log(thing.foo); //logs “foo”我喜欢把被赋值给prototype的函数叫做方法。在上面的例子中，我已经使用过方法了，如logFoo。这些方法有着相同的prototype，即创建这些实力的原始函数。我通常把这些原始函数叫做构造函数。在prototype里面定义的方法里面使用this会影响到当前实例的原型链的上游的this。这意味着你直接给this赋值的时候，隐藏了原型链上游的相同的属性值。这个实例的任何方法都会使用这个最新的值而不是原型里面定义的这个相同的值。1 function Thing1() {2 }3 Thing1.prototype.foo = “bar”;4 Thing1.prototype.logFoo = function () {5 console.log(this.foo);6 }78 function Thing2() {9 this.foo = “foo”;10 }11 Thing2.prototype = new Thing1();121314 var thing = new Thing2();15 thing.logFoo(); //logs “foo”;在JavaScript里面你可以嵌套函数，也就是你可以在函数里面定义函数。嵌套函数可以通过闭包捕获父函数的变量，但是这个函数没有继承this1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 var info = “attempting to log this.foo:”;6 function doIt() {7 console.log(info, this.foo);8 }9 doIt();10 }111213 var thing = new Thing();14 thing.logFoo(); //logs “attempting to log this.foo: undefined” 在doIt里面的this是global对象或者在严格模式下面是undefined。这是造成很多不熟悉JavaScript的人深陷 this陷阱的根源。在这种情况下事情变得非常糟糕，就像你把一个实例的方法当作一个值，把这个值当作函数参数传递给另外一个函数但是却不把这个实例传递给这个函数一样。在这种情况下，一个方法里面的环境变成了全局范围，或者在严格模式下面的undefined。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 console.log(this.foo);6 }78 function doIt(method) {9 method();10 }111213 var thing = new Thing();14 thing.logFoo(); //logs “bar”15 doIt(thing.logFoo); //logs undefined一些人喜欢先把this捕获到一个变量里面，通常这个变量叫做self，来避免上面这种情况的发生。博主非常喜欢用这种方式1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 var self = this;6 var info = “attempting to log this.foo:”;7 function doIt() {8 console.log(info, self.foo);9 }10 doIt();11 }121314 var thing = new Thing();15 thing.logFoo(); //logs “attempting to log this.foo: bar”但是当你需要把一个方法作为一个值传递给一个函数的时候并不管用。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 var self = this;6 function doIt() {7 console.log(self.foo);8 }9 doIt();10 }1112 function doItIndirectly(method) {13 method();14 }151617 var thing = new Thing();18 thing.logFoo(); //logs “bar”19 doItIndirectly(thing.logFoo); //logs undefined你可以通过bind将实例和方法一切传递给函数来解决这个问题，bind是一个函数定义在所有函数和方法的函数对象上面1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 console.log(this.foo);6 }78 function doIt(method) {9 method();10 }111213 var thing = new Thing();14 doIt(thing.logFoo.bind(thing)); //logs bar你同样可以使用apply和call来在新的上下文中调用方法或函数。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;4 Thing.prototype.logFoo = function () {5 function doIt() {6 console.log(this.foo);7 }8 doIt.apply(this);9 }1011 function doItIndirectly(method) {12 method();13 }141516 var thing = new Thing();17 doItIndirectly(thing.logFoo.bind(thing)); //logs bar你可以用bind来代替任何一个函数或者方法的this，即便它没有赋值给实例的初始prototype。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;456 function logFoo(aStr) {7 console.log(aStr, this.foo);8 }91011 var thing = new Thing();12 logFoo.bind(thing)(“using bind”); //logs “using bind bar”13 logFoo.apply(thing, [“using apply”]); //logs “using apply bar”14 logFoo.call(thing, “using call”); //logs “using call bar”15 logFoo(“using nothing”); //logs “using nothing undefined”你应该避免在构造函数里面返回任何东西，因为这可能代替本来应该返回的实例。1 function Thing() {2 return {};3 }4 Thing.prototype.foo = “bar”;567 Thing.prototype.logFoo = function () {8 console.log(this.foo);9 }101112 var thing = new Thing();13 thing.logFoo(); //Uncaught TypeError: undefined is not a function奇怪的是，如果你在构造函数里面返回了一个原始值，上面所述的情况并不会发生并且返回语句被忽略了。最好不要在你将通过new调用的构造函数里面返回任何类型的数据，即便你知道自己正在做什么。如果你想创建一个工厂模式，通过一个函数来创建一个实例，这个时候不要使用new来调用函数。当然这个建议是可选的。你可以通过使用Object.create来避免使用new，这样同样能够创建一个实例。1 function Thing() {2 }3 Thing.prototype.foo = “bar”;456 Thing.prototype.logFoo = function () {7 console.log(this.foo);8 }91011 var thing = Object.create(Thing.prototype);12 thing.logFoo(); //logs “bar”在这种情况下并不会调用构造函数1 function Thing() {2 this.foo = “foo”;3 }4 Thing.prototype.foo = “bar”;567 Thing.prototype.logFoo = function () {8 console.log(this.foo);9 }101112 var thing = Object.create(Thing.prototype);13 thing.logFoo(); //logs “bar”因为Object.create不会调用构造函数的特性在你继承模式下你想通过原型链重写构造函数的时候非常有用。1 function Thing1() {2 this.foo = “foo”;3 }4 Thing1.prototype.foo = “bar”;56 function Thing2() {7 this.logFoo(); //logs “bar”8 Thing1.apply(this);9 this.logFoo(); //logs “foo”10 }11 Thing2.prototype = Object.create(Thing1.prototype);12 Thing2.prototype.logFoo = function () {13 console.log(this.foo);14 }1516 var thing = new Thing2();object this在一个对象的一个函数里，你可以通过this来引用这个对象的其他属性。这个用new来新建一个实例是不一样的。1 var obj = {2 foo: “bar”,3 logFoo: function () {4 console.log(this.foo);5 }6 };78 obj.logFoo(); //logs “bar”注意，没有使用new，没有使用Object.create，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面。1 var obj = {2 foo: “bar”3 };45 function logFoo() {6 console.log(this.foo);7 }89 logFoo.apply(obj); //logs “bar”当你用这种方式使用this的时候，并不会越出当前的对象。只有有相同直接父元素的属性才能通过this共享变量1 var obj = {2 foo: “bar”,3 deeper: {4 logFoo: function () {5 console.log(this.foo);6 }7 }8 };910 obj.deeper.logFoo(); //logs undefined你可以直接通过对象引用你需要的属性var obj = {foo: “bar”,deeper: {logFoo: function () {console.log(obj.foo);}}};obj.deeper.logFoo(); //logs “bar”DOM event this在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点1 function Listener() {2 document.getElementById(“foo”).addEventListener(“click”,3 this.handleClick);4 }5 Listener.prototype.handleClick = function (event) {6 console.log(this); //logs ““7 }89 var listener = new Listener();10 document.getElementById(“foo”).click();除非你自己通过bind切换了上下文1 function Listener() {2 document.getElementById(“foo”).addEventListener(“click”,3 this.handleClick.bind(this));4 }5 Listener.prototype.handleClick = function (event) {6 console.log(this); //logs Listener {handleClick: function}7 }89 var listener = new Listener();10 document.getElementById(“foo”).click();HTML this在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素123 document.getElementById(“foo”).click(); //logs","categories":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/tags/javascript/"}]},{"title":"使用localstorage作为本地数据库以及跨域問題的解決","slug":"使用localstorage作为本地数据库","date":"2017-04-16T03:32:59.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"使用localstorage作为本地数据库/","link":"","permalink":"https://majunchang.github.io/使用localstorage作为本地数据库/","excerpt":"","text":"深入浅出Nodejs-04package.json 文件package.json 文件一般用来描述项目的一些基本信息，例如入口文件、依赖项、项目介绍、开发作者等数据。目前已知的两个非常重要的属性：mainmain 和模块化中的第三方包加载规则有关系dependenciesdependencies 和 npm 命令行工具有关系当你安装包的时候，如果加上 –save 参数，则npm会自动把这个第三方包依赖信息写入到 package.json 文件中的 dependencies 字段中当你执行 npm install 的时候，npm 会找到当前项目中的 package.json 文件中的 dependencies 依赖项，然后依次将所有的依赖下载下来这个文件最好每一个项目都有，保存一些项目的基本信息。这个文件可以通过 npm init 以向导的形式生成，也可以加上 -y 参数，一步生成。Express一个基于 Node 开发的一个快速 Web 开发框架主要用来构建 Serverhttp://expressjs.com/http://www.expressjs.com.cn/hello-worldvar express = require(&apos;express&apos;) // 1. 调用 express 方法，得到一个类似于 server 的实例 // 一般称作 app var app = express() // 2. 通过 app 根据不同的请求方法及请求路径设定具体的处理函数 // 当用户以 GET 请求 / 的时候，执行对应的回调处理函数 app.get(&apos;/&apos;, function (req, res) { res.end(&apos;hello world&apos;) }) // 当用户以 GET 请求 /login 的时候，执行对应的回调处理函数 app.get(&apos;/login&apos;, function (req, res) { res.end(&apos;hello login&apos;) }) // 3. 启动监听 app.listen(3000, function () { console.log(&apos;服务器已启动，请访问：http://127.0.0.1:3000/&apos;) }) 处理静态资源参考文档：http://www.expressjs.com.cn/starter/static-files.html通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。配置规则如下：app.use(&apos;路径访问前缀&apos;, express.static(&apos;资源目录路径&apos;)) 以下是一些配置示例：将目录 static 资源暴露出来，可以通过 /static/* 的形式进行访问app.use(‘/static/‘, express.static(‘static目录的绝对路径’))/static/css/a.css/static/css/b.css/static/img/ab2.jpg将目录 public 资源暴露出来，不需要任何前缀就可以访问app.use(express.static(‘public 目录的绝对路径’))/css/bb.css/img/a.jpg将目录 demo 资源暴露出来，可以通过 /aa/* /aa前缀的形式进行访问app.use(‘/aa/‘, express.static(‘demo 目录的绝对路径’))/aa/css/a.css/aa/*/.*将目录 static 资源暴露出来，可以通过 /static/ 或者 /aa/ 的形式进行访问app.use(‘/aa/‘, express.static(‘static 目录的绝对路径’))app.use(‘/static/‘, express.static(‘static 目录的绝对路径’))上面的形式就是把 static 目录中的资源提供了两种形式，既能以 /static/ 为前缀进行访问也可以以 /aa/ 的前缀进行访问路由系统在 Express 配置使用 ejs 模板引擎Express 这个框架很精简，默认是不支持模板引擎的，需要配合一些第三方的模板引擎来结合使用，例如这里将 ejs 和 express 结合起来使用：第一：安装 ejs：npm install --save ejs 第二：在代码中配置：app.set(&apos;views&apos;, 模板文件存储路径) // 注意，这里可以不配置，因为 Express 默认会去项目中的 `views` 目录进行查找 app.set(&apos;view engine&apos;, &apos;ejs&apos;) // 这里表示让 Express 中的 res.render 方法使用 ejs 模板引擎，这里的 ejs 就是你安装的那个模板引擎的包名 只要经过了上面这种配置，然后 res 对象上就会自动多出一个方法：res.render ,使用方式和咱们之前自己封装的一样：res.render(‘视图名称’, {要解析替换的对象数据})注意：使用了 ejs 模板引擎，默认视图文件后缀名必须是 .ejs，否则 render 方法找不到。如果想要修改，可以像下面这样：// app.set(&apos;view enginge&apos;, &apos;ejs&apos;) // 将上面这句配置改为下面的形式，就修改了默认的 .ejs 后缀名 app.engine(&apos;.html&apos;, require(&apos;ejs&apos;).__express) app.set(&apos;view engine&apos;, &apos;html&apos;) 在 Express 中配置使用 body-parser 插件解析处理表单 POST 请求体第一步：安装 body-parsernpm install --save body-parser 第二步，在代码中进行配置：app.use(bodyParser.urlencoded({ extended: false })) app.use(bodyParser.json()) 只要经过上面的安装配置，则在任意的 post 处理函数中都可以直接通过 req.body 来获取表单 POST 请求体数据。例如：app.post(&apos;login&apos;, function (req, res) { // 这里可以直接通过 req.body 来获取表单 POST 请求体数据 console.log(req.body) }) MongoDB数据库概念数据库：一个电子化的文件柜数据库就是为我们方便的管理数据的一个平台，例如对数据的存储、修改、查询等都非常的方便。数据库分类数据库产品有很多，以下是一些常见的数据库产品：MySQLOracleDB2SqlServerMongoDBetc.MongoDB 数据库（内存型的）为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.htmlMongoDB 数据库与mysql 等老牌数据库相比的优劣势安装与配置 MongoDB 数据库环境启动 MongoDB 服务实例可以通过使用安装程序中的 mongod CLI应用程序来启动 MongoDB 服务。直接在控制台输入：mongod 敲回车即可。在启动的时候，可以通过 –dbpath 指定数据服务存储数据的目录，如果不指定该目录，默认 mongod 会去 c:/data/db 作为自己的数据存储目录。64 位版本启动 MongoDB 数据服务：mongod --dbpath C:\\data\\db 32 位版本使用下面的命令启动数据服务：mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1 提示：如果不加 –dbpath, mongod 会自动使用 C:\\data\\db 目录作为自己的数据存储路径，所以，如果你已经有了 C:\\data\\db 目录了，可以省略 –dbpath。执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了，千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 Ctrl + C 关闭。连接 MongoDB 数据服务注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。打开一个新的控制台，在控制台输入以下命令用来连接本机的 MongoDB 服务实例：mongo mongo 命令默认去连接本机上的 MongoDB 服务实例：127.0.0.1:27017，可以通过下面的命令指定连接的主机名和端口号：mongo --host 127.0.0.1 --port 27017 如果看到类似于如下的字样说明连接成功：MongoDB shell version v3.4.0 connecting to: mongodb://127.0.0.1:27017 MongoDB server version: 3.4.0 Server has startup warnings: 2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] 2017-01-18T18:49:53.865+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database. 2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted. 2017-01-18T18:49:53.866+0800 I CONTROL [initandlisten] &gt; 如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。基本操作命令show dbs查看当前服务实例上所有的数据库use 数据库名称这个命令表示切换到指定的数据库如果没有，也不会创建如果已经有了，则表示切换到这个数据库对该数据库进行操作db查看当前所处的数据库db.集合名称.insert(数据文档)show collections查看当前数据库中所有的集合db.集合名称.find()查询指定集合中所有的数据可以通过 db.集合名称.find().pretty() 美化输出格式默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据db.集合名称.update({更新条件}, {要更新的字段})更新指定集合数据db.集合名称.remove({删除条件})删除指定集合中的数据使用 Node 操作 MongoDB项目结构如下 db为封装的Mongodb的增删改查方法，student为学生管理系统中分散的路由：安装 MongoDB 官方提供的驱动包：npm install --save mongodb 具体操作方式请参考官方文档：https://www.npmjs.com/package/mongodb使用原生方式操作MongoDBdbvar mongo = require(&apos;mongodb&apos;); var MongoClient = mongo.MongoClient; var url = &apos;mongodb://localhost:27017/itcast&apos;; // 获取到 数据库 单条数据本身的ObjectID，并把这个通过接口暴露出去 exports.ObjectID = mongo.ObjectID; exports.insertOne = function (collectionName, doc, callback) { MongoClient.connect(url, function (err, db) { if (err) { // 如果报错了 酒吧这个错误传递给外边的回调函数 return callback(err); } db.collection(collectionName) .insertOne(doc, function (err, result) { if (err) { return callback(err); } callback(null, result); db.close() }) }) } exports.findOne = function (collectionName, conditon, callback) { MongoClient.connect(url, function (err, db) { if (err) { // 如果报错了 酒吧这个错误传递给外边的回调函数 return callback(err); } db.collection(collectionName) .findOne(conditon, function (err, result) { if (err) { return callback(err); } callback(null, result); db.close() }) }) } exports.find = function (collectionName, condition, callback) { MongoClient.connect(url, function (err, db) { if (err) { // 如果报错了 酒吧这个错误传递给外边的回调函数 return callback(err); } db.collection(collectionName) .find(condition) .toArray(function (err, docs) { if (err) { return callback(err) } callback(null, docs); db.close(); }) }) } exports.deleteOne = function (collectionName, condiction, callback) { MongoClient.connect(url, function (err, db) { if (err) { return callback(err); } db.collection(collectionName) .deleteOne(condiction, function (err, result) { if (err) { return callback(err); } callback(null, result); }) }) } // 做编辑功能 exports.updateOne = function (collectionName, condition, changeDoc, callback) { MongoClient.connect(url,function (err, db) { if (err) { return callback(err) } db.collection(collectionName) .updateOne(condition, changeDoc, function (err, result) { if(err) { return callback(err); } callback(null, result); }) }) } student:var db = require(&apos;./db&apos;); // db 就是我们封装号的对象 通过require 来暴露接口 exports.index = function (req,res) { db.find(&apos;students&apos;,{},function (err,docs) { if(err) { // res.end(JSON.stringify({对象})) // res.json 是 Express 帮你扩展的一个方法，传入一个对象，自动帮你转为字符胡之后再去发送给客户端 return res.json({ err_no:500, message:&apos;查询数据失败，请稍后重试&apos; }) } console.log(docs) res.render(&apos;student/list&apos;,{ students:docs }) }) } exports.list = function (req, res) { db.find(&apos;students&apos;, {}, function (err, docs) { if (err) { return res.json({ err_no: 500, message: &apos;查询数据失败，请稍后重试&apos; }) } res.json({ err_no: 0, data: docs }) }) } exports.new = function (req,res) { res.render(&apos;student/new&apos;); } exports.doNew = function (req,res) { db.insertOne(&apos;students&apos;,req.body,function (err,result) { if(err) { return res.json({ err_no:500, message:&apos;服务器正忙，请稍后重试&apos; }) } res.json({ err_no:0, message:&apos;insert success&apos; }) }) } // 这是对查看按钮 做的操作 exports.info = function (req,res) { var id = req.query.id; db.findOne(&apos;students&apos;,{ _id:db.ObjectID(id) },function (err,doc) { if(err) { return res.json({ err_no:500, message:&apos;操作数据库失败了&apos; }) } console.log(doc); res.render(&apos;student/info&apos;,{ student:doc }) }) } exports.remove = function (req,res) { var id = req.query.id; db.deleteOne(&apos;students&apos;,{ _id:db.ObjectID(id) },function (err,result) { if(err) { return res.json({ err_no:500, message:&apos;操作数据库失败&apos; }) } res.json({ err_no:0, message:&apos;success&apos; }) /* res.redirect 就是重定向方法 告诉客户端浏览器 你重新请求这个路径把 对于异步请求来说 服务端的 redirect 无效的 red.redirect(&apos;/students&apos;) */ }) } // 制作编辑功能 exports.edit = function (req,res) { var id = req.query.id; console.log(id) db.findOne(&apos;students&apos;, { _id: db.ObjectID(id) }, function (err, doc) { if (err) { return res.json({ err_no: 500, message: &apos;读取数据失败，请稍后重试&apos; }) } res.render(&apos;student/edit&apos;, { student: doc, majors: [ &apos;java&apos;, &apos;ui&apos;, &apos;ios&apos;, &apos;前端与移动开发&apos;, &apos;全栈&apos; ] }) }) } exports.doEdit = function (req,res) { var body = req.body; var id = body.id; delete body.id; db.updateOne(&apos;students&apos;,{ _id:db.ObjectID(id) },{ $set:body },function (err,result) { if (err) { return res.json({ err_no: 500, message: &apos;更新失败，请稍后重试&apos; }) } res.json({ err_no: 0, message: &apos;success&apos; }) }) } 路由router：var express = require(&apos;express&apos;); var index = require(&apos;./controllers/index&apos;); var student = require(&apos;./controllers/student&apos;); var router = express.Router(); // 解析这句话 就是 当路径地址是 &apos;/&apos;的时候 会调用后来的这个方法来进行处理 router.get(&apos;/&apos;,index.index); // 一个是 求情主页 一个是请求new 页 router .get(&apos;/students&apos;,student.index) .get(&apos;/students/new&apos;,student.new) .get(&apos;/students/info&apos;,student.info) .post(&apos;/students/new&apos;,student.doNew) .get(&apos;/students/list&apos;,student.list) .get(&apos;/students/remove&apos;,student.remove) // 在这个地方设置编辑信息 // 有两种形式 一种是利用get的形式 一种是利用post的形式 .get(&apos;/students/edit&apos;,student.edit) .post(&apos;/students/edit&apos;,student.doEdit) // 暴露接口 module.exports = router; app：var express = require(&apos;express&apos;); var path = require(&apos;path&apos;); var router = require(&apos;./router&apos;); var bodyParser = require(&apos;body-parser&apos;); var app = express(); // 配置静态资源的访问路径 // 将node_module开放为公共资源 ，可以通过路径的形式直接访问该目录中的任意资源 app.use(&apos;/node_modules/&apos;,express.static(path.join(__dirname,&apos;node_modules&apos;))); app.set(&apos;views&apos;,path.join(__dirname,&apos;views&apos;)); //这一步设置 要注意 是view app.set(&apos;view engine&apos;,&apos;ejs&apos;); // 配置 body-parser插件 用来解析 表单post请求体 app.use(bodyParser.urlencoded({extended:false})); app.use(bodyParser.json()); // 挂载路由 app.use(router); app.listen(3000,function () { console.log(&apos;地狱之门已经开启，尽情的杀戮吧&apos;); }) 使用插件操作http://www.nodeclass.com/api/mongoose.html","categories":[],"tags":[]},{"title":"datatables插件使用详细说明","slug":"datatables插件使用详细说明","date":"2017-04-16T00:40:24.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"datatables插件使用详细说明/","link":"","permalink":"https://majunchang.github.io/datatables插件使用详细说明/","excerpt":"","text":"http://blog.csdn.NET/mickey_miki/article/details/8240477本文共四部分：官网 | 基本使用|遇到的问题|属性表一：官方网站：[http://www.datatables.NET/]二：基本使用：[http://www.guoxk.com/node/jQuery-datatables]DataTables的默认配置12345$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable();&#125; );示例：http://www.guoxk.com/html/DataTables/Zero-configuration.htmlDataTables的一些基础属性配置“bPaginate”: true, //翻页功能“bLengthChange”: true, //改变每页显示数据数量“bFilter”: true, //过滤功能“bSort”: false, //排序功能“bInfo”: true,//页脚信息“bAutoWidth”: true//自动宽度示例：http://www.guoxk.com/html/DataTables/Feature-enablement.html数据排序12345678910111213$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;aaSorting&quot;: [[ 4, &quot;desc&quot; ]]&#125; );&#125; );从第0列开始，以第4列倒序排列示例：http://www.guoxk.com/html/DataTables/Sorting-data.html多列排序示例：http://www.guoxk.com/html/DataTables/Multi-column-sorting.html隐藏某些列12345678910111213$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;aoColumnDefs&quot;: [&#123; &quot;bSearchable&quot;: false, &quot;bVisible&quot;: false, &quot;aTargets&quot;: [ 2 ] &#125;,&#123; &quot;bVisible&quot;: false, &quot;aTargets&quot;: [ 3 ] &#125;] &#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/Hidden-columns.html改变页面上元素的位置123456789101112131415161718192021222324252627$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;sDom&quot;: &apos;&lt;&quot;top&quot;fli&gt;rt&lt;&quot;bottom&quot;p&gt;&lt;&quot;clear&quot;&gt;&apos;&#125; );&#125; );//l- 每页显示数量//f - 过滤输入//t - 表单Table//i - 信息//p - 翻页//r - pRocessing//&lt; and &gt; - div elements//&lt;&quot;class&quot; and &gt; - div with a class//Examples: &lt;&quot;wrapper&quot;flipt&gt;, &lt;lf&lt;t&gt;ip&gt;示例：http://www.guoxk.com/html/DataTables/DOM-positioning.html状态保存，使用了翻页或者改变了每页显示数据数量，会保存在cookie中，下回访问时会显示上一次关闭页面时的内容。123456789$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;bStateSave&quot;: true&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/State-saving.html显示数字的翻页样式123456789$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;sPaginationType&quot;: &quot;full_numbers&quot;&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/Alternative-pagination-styles.html水平限制宽度12345678910111213$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;sScrollX&quot;: &quot;100%&quot;,&quot;sScrollXInner&quot;: &quot;110%&quot;,&quot;bScrollCollapse&quot;: true&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/Horizontal.html垂直限制高度示例：http://www.guoxk.com/html/DataTables/Vertical.html水平和垂直两个方向共同限制示例：http://www.guoxk.com/html/DataTables/HorizontalVerticalBoth.html####改变语言12345678910111213141516171819202122232425262728293031323334353637$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;oLanguage&quot;: &#123;&quot;sLengthMenu&quot;: &quot;每页显示 MENU 条记录&quot;,&quot;sZeroRecords&quot;: &quot;抱歉， 没有找到&quot;,&quot;sInfo&quot;: &quot;从 START 到 END /共 TOTAL 条数据&quot;,&quot;sInfoEmpty&quot;: &quot;没有数据&quot;,&quot;sInfoFiltered&quot;: &quot;(从 MAX 条数据中检索)&quot;,&quot;oPaginate&quot;: &#123;&quot;sFirst&quot;: &quot;首页&quot;,&quot;sPrevious&quot;: &quot;前一页&quot;,&quot;sNext&quot;: &quot;后一页&quot;,&quot;sLast&quot;: &quot;尾页&quot;&#125;,&quot;sZeroRecords&quot;: &quot;没有检索到数据&quot;,&quot;sProcessing&quot;: &quot;&quot;&#125;&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/Change-language-information.htmlclick事件示例：http://www.guoxk.com/html/DataTables/event-click.html配合使用tooltip插件示例：http://www.guoxk.com/html/DataTables/tooltip.html定义每页显示数据数量123456789$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;aLengthMenu&quot;: [[10, 25, 50, -1], [10, 25, 50, &quot;All&quot;]]&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/length_menu.htmlrow callback示例：http://www.guoxk.com/html/DataTables/RowCallback.html最后一列的值如果为“A”则加粗显示排序控制123456789101112131415161718192021$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;aoColumns&quot;: [null,&#123; &quot;asSorting&quot;: [ &quot;asc&quot; ] &#125;,&#123; &quot;asSorting&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ] &#125;,&#123; &quot;asSorting&quot;: [ ] &#125;,&#123; &quot;asSorting&quot;: [ ] &#125;]&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/sort.html说明：第一列点击按默认情况排序，第二列点击已顺序排列，第三列点击一次倒序，二三次顺序，第四五列点击不实现排序从配置文件中读取语言包12345678910111213$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;oLanguage&quot;: &#123;&quot;sUrl&quot;: &quot;cn.txt&quot;&#125;&#125; );&#125; );是用ajax源123456789101112$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;bProcessing&quot;: true,&quot;sAjaxSource&quot;: &apos;./arrays.txt&apos;&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/ajax.html使用ajax，在服务器端整理数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$(document).ready(function() &#123;$(&apos;#example&apos;).dataTable( &#123;&quot;bProcessing&quot;: true,&quot;bServerSide&quot;: true,&quot;sPaginationType&quot;: &quot;full_numbers&quot;,&quot;sAjaxSource&quot;: &quot;./server_processing.PHP&quot;,/*如果加上下面这段内容，则使用post方式传递数据&quot;fnServerData&quot;: function ( sSource, aoData, fnCallback ) &#123;$.ajax( &#123;&quot;dataType&quot;: &apos;json&apos;,&quot;type&quot;: &quot;POST&quot;,&quot;url&quot;: sSource,&quot;data&quot;: aoData,&quot;success&quot;: fnCallback&#125; );&#125;*/&quot;oLanguage&quot;: &#123;&quot;sUrl&quot;: &quot;cn.txt&quot;&#125;,&quot;aoColumns&quot;: [&#123; &quot;sName&quot;: &quot;platform&quot; &#125;,&#123; &quot;sName&quot;: &quot;version&quot; &#125;,&#123; &quot;sName&quot;: &quot;engine&quot; &#125;,&#123; &quot;sName&quot;: &quot;browser&quot; &#125;,&#123; &quot;sName&quot;: &quot;grade&quot; &#125;]//$_GET[&apos;sColumns&apos;]将接收到aoColumns传递数据&#125; );&#125; );示例：http://www.guoxk.com/html/DataTables/ajax-serverSide.html为每行加载id和class服务器端返回数据的格式：{“DT_RowId”: “row_8”,“DT_RowClass”: “gradeA”,“0”: “Gecko”,“1”: “Firefox 1.5”,“2”: “Win 98+ / OSX.2+”,“3”: “1.8”,“4”: “A”},示例：http://www.guoxk.com/html/DataTables/add_id_class.html为每行显示细节，点击行开头的“+”号展开细节显示示例：http://www.guoxk.com/html/DataTables/with-row-information.html选择多行示例：http://www.guoxk.com/html/DataTables/selectRows.html集成jQuery插件jEditable示例：http://www.guoxk.com/html/DataTables/jEditable-integration.html示例打包下载：http://www.guoxk.com/html/DataTables/DataTables.rar###、遇到的问题“Cannot reinitialise DataTable.To retrieve the DataTables object for this table, pass no arguments or see the docs for bRetrieve and bDestroy ”解决办法：http://blog.csdn.Net/mickey_miki/article/details/8239185排序时指定某列不可排序$(“.datatable”).dataTable( { &quot;aoColumnDefs&quot;: [ { &quot;bSortable&quot;: false, &quot;aTargets&quot;: [ 0 ] }] }); 注意： “bSort”: true, //排序功能 要注释掉确定选择每页展示个数列表和默认每页展示个数设置[javascript] view plain copy“aLengthMenu”: [[4, 10, 20, -1], [4, 10, 20, “所有”]],“iDisplayLength”:4属性表","categories":[{"name":"plugin","slug":"plugin","permalink":"https://majunchang.github.io/categories/plugin/"}],"tags":[]},{"title":"使用dataTable插件配置表格","slug":"使用dataTable插件配置表格","date":"2017-04-14T08:47:23.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"使用dataTable插件配置表格/","link":"","permalink":"https://majunchang.github.io/使用dataTable插件配置表格/","excerpt":"","text":"使用jquery的datatable插件 配置分页和查询功能安装以及引入使用npm进行安装npm install datatables –save1234567&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://cdn.datatables.net/1.10.13/css/jquery.dataTables.css\"&gt; &lt;!-- jQuery --&gt;&lt;script type=\"text/javascript\" charset=\"utf8\" src=\"http://code.jquery.com/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;!-- DataTables --&gt;&lt;script type=\"text/javascript\" charset=\"utf8\" src=\"http://cdn.datatables.net/1.10.13/js/jquery.dataTables.js\"&gt;&lt;/script&gt;下面给出一个示例以及配置选项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/datatables/media/css/jquery.dataTables.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=\"example\" class=\"display\" cellspacing=\"0\" width=\"80%\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Position&lt;/th&gt; &lt;th&gt;Office&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Start date&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Position&lt;/th&gt; &lt;th&gt;Office&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Start date&lt;/th&gt; &lt;th&gt;Salary&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Jena Gaines&lt;/td&gt; &lt;td&gt;Office Manager&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;2008/12/19&lt;/td&gt; &lt;td&gt;$90,560&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Quinn Flynn&lt;/td&gt; &lt;td&gt;Support Lead&lt;/td&gt; &lt;td&gt;Edinburgh&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;td&gt;2013/03/03&lt;/td&gt; &lt;td&gt;$342,000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Charde Marshall&lt;/td&gt; &lt;td&gt;Regional Director&lt;/td&gt; &lt;td&gt;San Francisco&lt;/td&gt; &lt;td&gt;36&lt;/td&gt; &lt;td&gt;2008/10/16&lt;/td&gt; &lt;td&gt;$470,600&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Haley Kennedy&lt;/td&gt; &lt;td&gt;Senior Marketing Designer&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;43&lt;/td&gt; &lt;td&gt;2012/12/18&lt;/td&gt; &lt;td&gt;$313,500&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tatyana Fitzpatrick&lt;/td&gt; &lt;td&gt;Regional Director&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;19&lt;/td&gt; &lt;td&gt;2010/03/17&lt;/td&gt; &lt;td&gt;$385,750&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Michael Silva&lt;/td&gt; &lt;td&gt;Marketing Designer&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;66&lt;/td&gt; &lt;td&gt;2012/11/27&lt;/td&gt; &lt;td&gt;$198,500&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Paul Byrd&lt;/td&gt; &lt;td&gt;Chief Financial Officer (CFO)&lt;/td&gt; &lt;td&gt;New York&lt;/td&gt; &lt;td&gt;64&lt;/td&gt; &lt;td&gt;2010/06/09&lt;/td&gt; &lt;td&gt;$725,000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Gloria Little&lt;/td&gt; &lt;td&gt;Systems Administrator&lt;/td&gt; &lt;td&gt;New York&lt;/td&gt; &lt;td&gt;59&lt;/td&gt; &lt;td&gt;2009/04/10&lt;/td&gt; &lt;td&gt;$237,500&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bradley Greer&lt;/td&gt; &lt;td&gt;Software Engineer&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;41&lt;/td&gt; &lt;td&gt;2012/10/13&lt;/td&gt; &lt;td&gt;$132,000&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Dai Rios&lt;/td&gt; &lt;td&gt;Personnel Lead&lt;/td&gt; &lt;td&gt;Edinburgh&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;td&gt;2012/09/26&lt;/td&gt; &lt;td&gt;$217,500&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jenette Caldwell&lt;/td&gt; &lt;td&gt;Development Lead&lt;/td&gt; &lt;td&gt;New York&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;2011/09/03&lt;/td&gt; &lt;td&gt;$345,000&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;图片显示###效果如下：接下来是配置选项，在配置之前，我们需要引入jq和datatable插件12345678910111213141516171819202122232425262728293031323334&lt;script src=\"node_modules/jquery/dist/jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"node_modules/datatables/media/js/jquery.dataTables.js\"&gt;&lt;/script&gt;&lt;script&gt; window.onload = function () &#123; $('#example').dataTable(&#123; bLengthChange: false, bFilter: true, bInfo: false, bSort: true, select: false, sPaginationType: \"full_numbers\", sSearchPlaceholder: '请输入筛选关键字', bRetrieve: true, iDisplayLength: 5, oLanguage: &#123; sLengthMenu: \"每页显示 _MENU_ 条数据\", sInfo: \"从 _START_ 到 _END_ /共 _TOTAL_ 条数据\", sInfoEmpty: \"没有数据\", sInfoFiltered: \"(从 _MAX_ 条数据中检索)\", sZeroRecords: \"没有检索到数据\", sSearchPlaceholder: '请输入筛选关键字', sSearch: \"筛选\", oPaginate: &#123; sFirst: \"首页\", sPrevious: \"前一页\", sNext: \"后一页\", sLast: \"尾页\" &#125; &#125;, order:[[2,'asc']] &#125;) &#125;&lt;/script&gt;","categories":[{"name":"plugin","slug":"plugin","permalink":"https://majunchang.github.io/categories/plugin/"}],"tags":[]},{"title":"$.ajax参数详解","slug":"ajax参数详解","date":"2017-04-08T07:25:57.000Z","updated":"2018-10-23T13:12:13.000Z","comments":true,"path":"ajax参数详解/","link":"","permalink":"https://majunchang.github.io/ajax参数详解/","excerpt":"","text":"jquery中的ajax的各个参数的详细解读参数options类型：Object可选。AJAX 请求设置。所有选项都是可选的。async类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。beforeSend(XHR)类型：Function发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。cache类型：Boolean默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。jQuery 1.2 新功能。complete(XHR, TS)类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。参数： XMLHttpRequest 对象和一个描述请求类型的字符串。这是一个 Ajax 事件。contentType类型：String默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。context类型：Object这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。就像这样：$.ajax({ url: “test.html”, context: document.body, success: function(){$(this).addClass(“done”);}});data类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。dataFilter类型：Function给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。dataType类型：String预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:“xml”: 返回 XML 文档，可用 jQuery 处理。“html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。“script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）“json”: 返回 JSON 数据 。“jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。“text”: 返回纯文本字符串error类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。global类型：Boolean是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。ifModified类型：Boolean仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。jsonp类型：String在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。jsonpCallback类型：String为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。password类型：String用于响应 HTTP 访问认证请求的密码processData类型：Boolean默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。scriptCharset类型：String只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。success类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。traditional类型：Boolean如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。timeout类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。type类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。url类型：String默认值: 当前页地址。发送请求的地址。username类型：String用于响应 HTTP 访问认证请求的用户名。类型：Function需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。回调函数如果要处理 $.ajax() 得到的数据，则需要使用回调函数：beforeSend、error、dataFilter、success、complete。beforeSend在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。error在请求出错时调用。传入 XMLHttpRequest 对象，描述错误类型的字符串以及一个异常对象（如果有的话）dataFilter在请求成功之后调用。传入返回的数据以及 “dataType” 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。success当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。","categories":[{"name":"ajax","slug":"ajax","permalink":"https://majunchang.github.io/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://majunchang.github.io/tags/ajax/"}]},{"title":"使用ajax发送form表单数据","slug":"使用ajax发送form表单数据","date":"2017-04-08T03:41:12.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"使用ajax发送form表单数据/","link":"","permalink":"https://majunchang.github.io/使用ajax发送form表单数据/","excerpt":"","text":"使用ajax向后台发送json格式的form表单数据使用场景是在vue的一个组件之中，前端通过form表单组合数据，而后台需要 将form表单 进行json格式的转化processData：processData 默认为true，当设置为false的时候,jQuery ajax 提交的时候不会序列化 data，而是直接使用data举例说明；设置为true 会进行序列化。{ width:1680, height:1050 }参数对象序列化为width=1680&amp;height=1050这样的字符串。contentType：默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型 适用于大多数情况。s = jQuery.ajaxSetup( {}, options ), // Convert data if not already a string if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== \"string\" ) { s.data = jQuery.param( s.data, s.traditional ); } 序列化一个 key/value 对象： var params = { width:1900, height:1200 }; var str = jQuery.param(params); $(\"#results\").text(str); 结果: width=1680&amp;height=1050 var _this = this; this.$message.modal({ header: '导出到生成平台', body: ` &lt;form action=\"https://10.10.11.105:9001/genplatform-rest/api/upload/projectmeta\" id='exportli' method='post' enctype='multipart/form-data'&gt; &lt;button&gt;用户名&lt;/button&gt; &lt;input type=\"text\" name=\"userName\" required&gt;&lt;br&gt; &lt;button&gt;密码&lt;/button&gt; &lt;input type=\"text\" name=\"passWord\" required&gt;&lt;br&gt; &lt;button&gt;用户组列表&lt;/button&gt; &lt;input type=\"text\" name=\"groupName\" required&gt;&lt;br&gt; &lt;button&gt;项目列表&lt;/button&gt; &lt;input type=\"text\" name=\"projectName\" required&gt;&lt;br&gt; &lt;input type=\"text\" name=\"projectMeta\" hidden id='file'&gt; &lt;/form&gt;`, primaryClick: () =&gt; { $.ajax({ url: `${_this.appConfig.apiBase}project/download/${_this.$route.params.id}`, type: 'get', cache: false, processData: false, contentType: false, success: (data) =&gt; { var fileInput = document.getElementById('file'); fileInput.value = data; let formData = $('#exportli').serialize(); console.log(formData); console.log(JSON.stringify(formData)); $.ajax({ url: 'https://10.10.11.105:9001/genplatform-rest/api/upload/projectmeta', type: \"POST\", data: formData, cache: false, processData: false, contentType: 'application/x-www-form-urlencoded', success: (data) =&gt; { if (data.code === 0) { this.$message.hide(); this.$message.alert('导出到生成平台成功！'); } else { this.appConfig.showErrorAlert(data.code); } }, error: (data) =&gt; { this.appConfig.showErrorAlert(); } }) }, error: (data) =&gt; { this.appConfig.showErrorAlert(); } }) } }) }","categories":[{"name":"ajax","slug":"ajax","permalink":"https://majunchang.github.io/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://majunchang.github.io/tags/ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"https://majunchang.github.io/tags/jQuery/"}]},{"title":"前端如何进行压缩下载","slug":"前端如何进行压缩下载","date":"2017-04-08T03:40:49.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"前端如何进行压缩下载/","link":"","permalink":"https://majunchang.github.io/前端如何进行压缩下载/","excerpt":"","text":"前端实现 将字符串放入指定的文件名，并将指定的文件 进行压缩下载。需要使用 jszip和FileSaver这两个插件此处插入一张图片 这样看起来美观1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" onclick=\"create_zip()\" value=\"创建压缩包并下载\"/&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=\"./node_modules/jszip/dist/jszip.js\"&gt;&lt;/script&gt;&lt;script src=\"./node_modules/file-saver/FileSaver.js\"&gt;&lt;/script&gt;&lt;script&gt; function create_zip() &#123; var zip = new JSZip(); zip.file(\"hello1.txt\", \"Hello majunchang World\\n\"); zip.file(\"hello2.txt\", \"Hello liuyifei World\\n\"); zip.generateAsync(&#123;type:\"blob\"&#125;) .then(function(content) &#123; saveAs(content, \"liuyifei.zip\"); &#125;); &#125;&lt;/script&gt;","categories":[{"name":"plugin","slug":"plugin","permalink":"https://majunchang.github.io/categories/plugin/"}],"tags":[]},{"title":"深入理解javascript闭包特性","slug":"深入理解javascript闭包特性","date":"2017-04-03T03:12:38.000Z","updated":"2018-10-23T12:57:18.000Z","comments":true,"path":"深入理解javascript闭包特性/","link":"","permalink":"https://majunchang.github.io/深入理解javascript闭包特性/","excerpt":"","text":"闭包的原理在函数外部使用函数内部的数据上级作用域无法访问下级作用域中的变量，但是下级作用域可以访问上级作用域的变量1234567function outer()&#123; var data = \"\"; function inner()&#123; return data; &#125; return inner;&#125;闭包的应用举例可以将数据保护起来，外接想要修改数据，只能通过指定的渠道给函数添加一个私有的变量浅谈javascript闭包的特性闭包，是指语法域位于某个特定的区域，具有持续参照（读写）位于该区域内自身范围之外的执行域上的非持久型变量值能力的段落。Javascript闭包的定义非常晦涩——闭包，是指语法域位于某个特定的区域，具有持续参照（读写）位于该区域内自身范围之外的执行域上的非持久型变量值能力的段落。简单来说，Javascript闭包就是在另一个作用域中保存了一份它从上一级函数或作用域取得的变量123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000使用闭包的注意点闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便更改父函数内部变量的值","categories":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/categories/javascript/"}],"tags":[]},{"title":"gulp工具总结","slug":"gulp工具总结","date":"2017-03-26T01:39:30.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"gulp工具总结/","link":"","permalink":"https://majunchang.github.io/gulp工具总结/","excerpt":"","text":"Gulp TutorialGulp: The streaming build systemgulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。常见处理任包括以下几方面：模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件；对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能；以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack等。Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，其以简洁的配置和卓越的性能成为目前主流的构建工具。Introduction官方：http://gulpjs.com/中文官网：http://www.gulpjs.com.cn/npm：https://www.npmjs.com/package/gulpGithub：https://github.com/gulpjs/gulpGitbook：https://wizardforcel.gitbooks.io/gulp-doc/content/2.htmlGetting Started官方文档：https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md一：Install the gulp command在项目中使用 gulp 首先需要确保全局有 gulp-cli 环境，如果有就不需要执行下面的命令了。12# npm install --global gulp-cliyarn global add gulp-cli二：Install gulp in your devDependencies12# npm install --save-dev gulpyarn add -D gulp三：Create a file called gulpfile.js in your project root with these contents:12345var gulp = require('gulp');gulp.task('default', function() &#123; console.log('hello gulp')&#125;)四：Test it out: Run the gulp command in your project directory:1gulpAPI Documentation官方文档：https://github.com/gulpjs/gulp/blob/master/docs/API.mdgulp.taskgulp.srcgulp.destgulp.watchgulp.task(name [, deps] [, fn])作用：定义各种不同的任务gulp.task(name, fn)gulp.task(name, deps, fn)gulp.task(name, fn(cb))gulp.task(name, deps, fn(cb))一：普通任务1234567gulp.task('a', function () &#123; console.log('1 aaa')&#125;)gulp.task('b', function () &#123; console.log('2 bbb')&#125;)二：任务之间的依赖1234567891011gulp.task('a', function (cb) &#123; setTimeout(function () &#123; console.log('1 aaa') cb() &#125;, 1000)&#125;)// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的gulp.task('b', ['a'], function () &#123; console.log('2 bbb')&#125;)三：gulp 流控制12345678910gulp.task('a', function () &#123; // 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序 return gulp.src() .pipe() // ...&#125;)gulp.task('b', ['a'], function () &#123; // doSomething&#125;)gulp.src(globs[, options])gulp教程之gulp中文API：http://www.ydcss.com/archives/424作用：根据路径（字符串或数组）读取需要构建的资源globs需要处理的源文件匹配符路径。类型(必填)：String or StringArray，通配符路径匹配示例：src/a.js 指定具体文件；* 匹配所有文件 例：src/*.js (包含src下的所有js文件)；** 匹配0个或多个子文件夹 例：src/**/*.js (包含src的0个或多个子文件夹下的js文件)；{} 匹配多个属性 例：src/{a,b}.js (包含a.js和b.js文件) src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；! 排除文件 例：!src/a.js (不包含src下的a.js文件)；options.baseoptions.base：类型：String 设置输出路径以某个路径的某个组成部分为基础向后拼接，具体看下面示例：1234567gulp.src('client/js/**/*.js') .pipe(minify()) .pipe(gulp.dest('build')) // Writes 'build/somedir/somefile.js' gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;) .pipe(minify()) .pipe(gulp.dest('build')) // Writes 'build/js/somedir/somefile.js'gulp.dest(path[, options])作用：构建任务完成后资源存放的路径gulp.watch(glob[, opts], tasks)监视指定资源的改动，然后可以调用响应的任务处理gulp.watch(glob [, opts, cb])常用插件插件名称作用del删除文件或文件夹gulp-less编译LESS文件gulp-rname重命名文件gulp-imagemin图片压缩gulp-uglify压缩Javascriptgulp-concat合并 js 文件gulp-concat-css合并 css 文件gulp-cssnano压缩 cssgulp-htmlmin压缩HTMLgulp-rev添加版本号gulp-rev-collector内容替换gulp-userefgulp-ifgulp-load-plugins依赖自动加载gulp-useref自动合并打包处理gulp-wrap包装内容gulp-angular-templatecacheAngularJS 模板缓存browser-sync和 gulp 配合使用实现文件改变执行某个任务后自动刷新yargs获取命令行参数gulp-if根据判断执行某个插件","categories":[],"tags":[]},{"title":"webpack和ESLlint的搭配","slug":"webpack和ESLlint的搭配","date":"2017-02-06T12:59:18.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"webpack和ESLlint的搭配/","link":"","permalink":"https://majunchang.github.io/webpack和ESLlint的搭配/","excerpt":"","text":"esLint介绍做代码统一风格规范jslintjshinteslintEslint官网：http://eslint.cn/docs/user-guide/configuring快速开始全局和本地安装eslintnpm install eslint -gnpm install eslint -save-dev创建并编写配置文件配置文件可以写成好多种方式.eslintrc.js（主流，推荐）.eslintrc.yaml文件.eslintrc.json注释的写法可以直接配置在webpack的属性中可以配置在npm的package.json文件中在webpack中配置eslint-loader下载npm install eslint-loader -save-dev指定eslint的配置文件,如果不指定有默认的优先执行顺序在loader中配置加载器通过.eslintignore文件指定不需要走eslint规范的代码之后执行webpack的运行命令就可以看到效果了特殊支持React的支持如果用了ES6的新语法那么需要下载一个模块支持，否则react中写定义箭头函数会报错npm install babel-eslint -save在.eslintrc配置文件中添加&quot;parser&quot;: &quot;babel-eslint&quot;自定义语法规则http://eslint.cn/docs/rules/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// eslint的语法规则module.exports = &#123; // 开启推荐配置信息 // \"extends\": \"eslint:recommended\", // 默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里的 eslintConfig 字段下设置 \"root\": true。ESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。 \"root\": true, // 脚本在执行期间访问的额外的全局变量 // 当访问未定义的变量时，no-undef 规则将发出警告。如果你想在一个文件里使用全局变量，推荐你定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。 \"globals\" : &#123; \"window\":true, \"document\":true, \"$\":true &#125;, // 设置插件 // \"plugins\": [ // 'html' // ], // 设置解析器选项（必须设置这个属性） \"parserOptions\": &#123; \"ecmaVersion\": 7, \"sourceType\": \"module\", \"ecmaFeatures\": &#123; \"jsx\": true, // \"arrowFunctions\": true, // \"experimentalObjectRestSpread\": true, // \"classes\": true, // \"modules\": true, // \"defaultParams\": true &#125; &#125;, // 启用的规则及各自的错误级别 \"rules\" : &#123; // 禁止用console \"no-console\":0, // 禁止用分号 \"semi\":[2,'never'], // 在同一个作用域中禁止多次重复定义 \"no-redeclare\":1 &#125;, // 指定你想启用的环境 \"env\": &#123; \"browser\": true, \"node\": true &#125;, \"parser\": \"babel-eslint\"&#125;;注意点eslint的代码规范只在开发阶段用参考文章一些规则的中文说明:http://blog.csdn.net/helpzp2008/article/details/51507428http://www.tuicool.com/articles/rIFBfey","categories":[{"name":"webpack","slug":"webpack","permalink":"https://majunchang.github.io/categories/webpack/"}],"tags":[{"name":"webpack和ESlint的搭配","slug":"webpack和ESlint的搭配","permalink":"https://majunchang.github.io/tags/webpack和ESlint的搭配/"}]},{"title":"webpack的环境搭建","slug":"webpack的环境搭建","date":"2017-02-04T00:30:05.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"webpack的环境搭建/","link":"","permalink":"https://majunchang.github.io/webpack的环境搭建/","excerpt":"","text":"webpack2基本介绍介绍webpack和gulp一样是一个自动化的构建工具你不想做的东西都交给工具去做，比如混淆，压缩，移动，合并，添加浏览器兼容性词缀gulp更适合做简单的流程性的操作，webpack是专门为处理SPA应用的复杂文件依赖而出现的如图js引用css，js引用图片，css引用图片，css引用字体，sass引用sasswebpack就可以把上面的东西css都抽出来，所有的图片都抽出来webpack主要用于react和vue的构建,普通的静态页面用gulp就足够了官网webpack2:https://webpack.js.org/webpack1:http://webpack.github.io/docs/webpack1和webpack2的一些区别webpack2已经不支持在配置文件中自定义属性webpack2中在加载器中如果用了options属性那么必须配合loader属性使用，不能用usewebpack2中-loader一定要写全webpack2中webpack-dev-server要单独下载2.x版本，默认是下载1.x版本快速开始新建项目结构安装依赖npm install webpack -gnpm install webpack -save-dev编写配置文件1234567891011var path=require(&apos;path&apos;)module.exports = &#123; // 指定spa应用的入口文件 entry: path.resolve(__dirname, &apos;src/js/app.js&apos;), // 指定项目构建的输出位置 output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos;, &#125;&#125;运行在项目根目录执行webpack可以启动默认配置文件webpack.config.js运行指定配置文件执行webpack --config webpack.develop.config.js把运行命令放到package.json文件中启动命令还可以加很多参数webpack --config webpack.develop.config.js --progress --profile --colors这么多参数不可能都记住，所以将启动命令写到package.json的script标签中监听代码变化自动重新构建代码的变动需要多次运行npm run develop所以我们需要自动监听代码变动，然后运行构建，于是我们用到了webpack-dev-server这个模块webpack-deve-server介绍webpack-dev-server封装了webpack和http模块所以webpack的所有命令，webpack-deve-server都可以使用webpack-dev-server可以指定一个文件夹启动一个服务webpack-dev-server启动的服务所有的内容都构建在内存中因为构建在内存中速度快，还有一个功能，就是没有变化的文件，不重新构建，只有变化了的文件才从新执行构建作用一是监听文件变化自动重新构建二是自动刷新浏览器，可以热更新基本使用下载npm install webpack-dev-server@9.9.9 -save-dev,注意选择2.x版本的模块修改package.json文件中的命令webpack-dev-server --config webpack.develop.config.js --progress --profile --colors修改开发配置文件webpack2中推荐所有的服务配置信息都写到配置文件中的devServer属性中，不要写在package.json中基本配置12345678910111213devServer: &#123; // 指定启动服务的更目录 contentBase: __dirname + &apos;/src&apos;, // 指定端口号 port: 8080, host: &apos;localhost&apos;, // 以下信息可有可无，为了完整 inline: true, historyApiFallback: true, noInfo: false, // stats: &apos;minimal&apos;, // publicPath: publicPath&#125;,热更新可以不刷新浏览器更新修改配置文件123456789101112131415devServer: &#123; // 指定启动服务的更目录 contentBase: __dirname + &apos;/src&apos;, // 指定端口号 port: 8080, host: &apos;localhost&apos;, // 启用热更新 hot: true, // 以下信息可有可无，为了完整 inline: true, historyApiFallback: true, noInfo: false, // stats: &apos;minimal&apos;, // publicPath: publicPath&#125;,需要配合一个内置插件一起使用12345var webpack=require(&apos;webpack&apos;)plugins: [ new webpack.HotModuleReplacementPlugin(),]Loaders（加载器）在真正构建之前做一些预处理操作就叫加载器处理es6、es7、jsx语法加载器npm install babel-loader --save-devnpm install babel-core babel-preset-es2015 babel-preset-react -save-devnpm install babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3 --save-devnpm install babel-plugin-transform-runtime -save-dev这个插件的作用是支持es7特性修改配置文件12345678910111213module: &#123; rules: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, use: [ &#123; loader: &quot;babel-loader&quot; &#125; ] &#125; ] &#125;创建.babelrc文件12345678910111213&#123; &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot;, &quot;stage-0&quot;, &quot;stage-1&quot;, &quot;stage-2&quot;, &quot;stage-3&quot; ], &quot;plugins&quot;: [ &quot;transform-runtime&quot; ]&#125;处理css文件引用的加载器npm install style-loader css-loader -save-dev修改配置文件12345 // 处理在js中引用css文件&#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;],&#125;,处理scss或者less文件引用的加载器npm install sass-loader less-loader node-sass -save-dev修改配置文件123456789 // 处理在js中引用scss文件&#123; test: /\\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],&#125;,&#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;],&#125;,处理图片引用的加载器npm install url-loader file-loader -save-dev修改配置文件12345// 处理图片操作 25000bit ~3kb&#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &apos;url-loader&apos;&#125;,处理字体文件引用的加载器npm install url-loader file-loader -save-dev修改配置文件12345// 处理字体文件&#123; test: /\\.(eot|woff|ttf|woff2|svg)$/, use: &apos;url-loader&apos;&#125;发布策略简单的说就是将开发阶段的配置文件复制一份到部署的配置文件中，然后删删改改就可以了把热更新插件删除，devServer属性删除修改图片处理和字体处理加载器12345678910 // 处理图片操作 25000bit ~3kb&#123; test: /\\.(png|jpg|jpeg|gif)$/, use: &apos;url-loader?limit=25000&amp;name=images/[name].[ext]&apos;&#125;,// 处理字体文件&#123; test: /\\.(eot|woff|ttf|woff2|svg)$/, use: &apos;url-loader?limit=100000&amp;name=fonts/[name].[ext]&apos;&#125;接下来运行npm run publish就发布了不过要注意所有的css，js，图片都构建到一个bundle.js文件中了Plugins（插件）在真正构建之后做一些后处理操作就叫插件删除插件npm install clean-webpack-plugin -save-dev使用123456var CleanPlugin = require(&apos;clean-webpack-plugin&apos;);plugins: [ // 删除文件夹的插件 new CleanPlugin([&apos;dist&apos;])]抽取公共js插件使用12345678910 entry: &#123; app: path.resolve(__dirname, &apos;src/js/app.js&apos;), vendors: [&apos;vue&apos;,&apos;vue-router&apos;,&apos;vuex&apos;] &#125;, plugins: [ // 分离第三方应用的插件 new webpack.optimize.CommonsChunkPlugin(&#123;name: &apos;vendors&apos;, filename: &apos;vendors.js&apos;&#125;),]提取样式文件插件npm install extract-text-webpack-plugin@4.4.4 -save-dev注意下载2.x版本使用12345678910111213141516171819202122232425// 1、抽取css的第三方插件var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);// 2、处理在js中引用css文件&#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallbackLoader: &quot;style-loader&quot;, loader: &quot;css-loader&quot; &#125;)&#125;,// 处理在js中引用scss文件&#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallbackLoader: &quot;style-loader&quot;, loader: &quot;css-loader!sass-loader&quot; &#125;)&#125;,//3、加一个插件plugins: [ // 删除文件夹的插件 new ExtractTextPlugin(&quot;app.css&quot;),]自动生成html插件npm install html-webpack-plugin -save-dev在根目录创建template.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;title&gt;webpack学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;修改配置文件12345678910111213141516171819var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);plugins: [ // 自动生成html插件 new HtmlWebpackPlugin(&#123; template: &apos;./src/template.html&apos;, htmlWebpackPlugin: &#123; &quot;files&quot;: &#123; &quot;css&quot;:[&quot;app.css&quot;], &quot;js&quot;: [&quot;vendors.js&quot;, &quot;bundle.js&quot;] &#125; &#125;, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;),]压缩插件修改配置文件123456789101112131415plugins: [ // 压缩混淆js代码插件 new webpack.optimize.UglifyJsPlugin(&#123; beautify: false, mangle: &#123; screw_ie8: true, keep_fnames: true &#125;, compress: &#123; warnings: false, screw_ie8: true &#125;, comments: false &#125;),]定义生产环境插件修改配置文件12345678plugins: [ // 在构建的过程中删除警告 new webpack.DefinePlugin(&#123; &apos;process.env&apos;:&#123; NODE_ENV:&apos;&quot;production&quot;&apos; &#125; &#125;)]自动打开浏览器插件npm install open-browser-webpack-plugin -save-dev使用1234567// 自动打开浏览器插件var OpenBrowserPlugin = require(&apos;open-browser-webpack-plugin&apos;)plugins: [ // 删除文件夹的插件 new OpenBrowserPlugin(&#123;url: &apos;http://localhost:8080/&apos;, browser: &apos;chrome&apos;&#125;)]高级和gulp的集成npm install gulp del gulp-sequence -save-dev编写配置文件123456789101112131415161718192021222324252627282930313233343536373839404142// gulp的任务是控制执行流程，webpack的任务是处理复杂引用的依赖var gulp = require(&apos;gulp&apos;);// 删除文件和目录var del = require(&apos;del&apos;);// 按顺序执行var gulpSequence = require(&apos;gulp-sequence&apos;);// 引入webpack的本地模块var webpack = require(&quot;webpack&quot;);// 引入wbpack的配置文件var webpackConfig = require(&quot;./webpack.publish.config.js&quot;);gulp.task(&apos;default&apos;, [&apos;sequence&apos;], function () &#123; console.log(&quot;项目构建成功&quot;);&#125;);// 流程控制gulp.task(&apos;sequence&apos;, gulpSequence(&apos;clean&apos;,&apos;webpack&apos;));// 删除文件和文件夹gulp.task(&apos;clean&apos;, function (cb) &#123; //del(&apos;dist);// 如果直接给dist的目录，项目启动的顺序还有清除结果会报错，所以要写的更详细一些 del([&apos;dist/*.js&apos;, &apos;dist/*.css&apos;, &apos;dist/images&apos;, &apos;dist/fonts,&apos;,&apos;dist/*.html&apos;]).then(function () &#123; cb() &#125;);&#125;);//写一个任务，在gulp中执行webpack的构建// gulp 负责任务流程部分的操作，webpack负责复杂模块系统的引用分离工作gulp.task(&apos;webpack&apos;, function (cb) &#123; // 执行webpack的构建任务 webpack(webpackConfig, function (err, stats) &#123; if (err) &#123; console.log(&quot;构建任务失败&quot;); &#125; else &#123; cb(); &#125; &#125;);&#125;);和eslint的集成其他（我的）组件库按需加载处理react中的antd按需加载配置1234567npm install babel-plugin-import -save-dev&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;react&quot;,&quot;stage-0&quot;,&quot;stage-1&quot;,&quot;stage-2&quot;,&quot;stage-3&quot;], &quot;plugins&quot;: [ [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;,&quot;style&quot;: &quot;css&quot; &#125;] ]&#125;vue总的element按需加载配置1234567891011121314151617181920212223npm install babel-plugin-component-save-dev&#123; &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot;, &quot;stage-0&quot;, &quot;stage-1&quot;, &quot;stage-2&quot;, &quot;stage-3&quot; ], &quot;plugins&quot;: [ &quot;transform-runtime&quot;, [ &quot;component&quot;, [ &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-default&quot; &#125; ] ] ]&#125;","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://majunchang.github.io/categories/Nodejs/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://majunchang.github.io/tags/webpack/"}]},{"title":"node和mongdb","slug":"node和mongdb","date":"2016-11-20T02:33:24.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"node和mongdb/","link":"","permalink":"https://majunchang.github.io/node和mongdb/","excerpt":"","text":"1 原生操作数据库 和 使用插件操作数据库 (mongoose)第一种方式 ：使用原生node1 定义1个db模块123var mongo = require('mongodb');var mongoClient = mongo.MongoClient;var url = 'mongodn://localhost:27017/itcast';2 将db 暴露给其他的 处理模块使用的时候 这样使用就可以了：db.find…// 传入响应的参数第二种方式 ：使用插件mongoose引入插件 连接数据库 声明数据模板import mongoose from ‘mongoose’mongoose.conmect(‘mongodb://localhost/edu’);const advertSchema = new mongoose.Schema({//这个里面写单条数据的 数据结构 })2 将这个模板 暴露出去export default mongoose.model(‘Advert’,advertSchema)3 在需要使用的地方进行接受 接受的时候 格式要对应import {Advert} from ‘//相应的文件’使用Advert 进行操作 增删差改2 使用express 配置访问静态路径 这个 join 引用的是 path里面的join 这个path 是nodejs自带的东西使用ejs 配置模板引擎 默认是找后缀名为ejs的文件 ，这个是需要单独安装的。使用babel解析ecma6 这个具体的配置在阮一峰的博客上面123456app.use('/node_modules', express.static(config.node_modules_path))app.use('/public', express.static(config.public_path))viewPath: join(__dirname, '../views'),node_modules_path: join(__dirname, '../node_modules'),public_path: join(__dirname, '../public')3 详解express中间件12345678910111213141516const express = require('express')const fs = require('fs')const path = require('path')const static = require('./middlwares/static')const app = express()app.use((req, res, next) =&gt; &#123; const log = `请求方法：$&#123;req.method&#125; 请求路径：$&#123;req.url&#125; 请求时间：$&#123;+new Date()&#125;\\n` fs.appendFile('./log.txt', log, err =&gt; &#123; if (err) &#123; return console.log('记录日志失败了') &#125; next() &#125;)&#125;)1234567891011121314151617181920212223242526// 中间件：用来处理 http 请求的一个具体的环节（可能要执行某个具体的处理函数）// 中间件一般都是通过修改 req 或者 res 对象来为后续的处理提供便利的使用// 中间件分类：// use(function () &#123;req, res, next&#125;) 不关心请求方法和请求路径，没有具体路由规则，任何请求都会进入该中间件// use('请求路径', function (req, res, next) &#123;&#125;) 不关心请求方法，只关心请求路劲的中间件// get('请求路径', function (req, res, next) &#123;&#125;) 具体路由规则中间件// post('请求路径', function (req, res, next) &#123;&#125;)// 中间件的作用：// // app.use('/public', express.static('开放目录的路径'))// 在 use 方法中，如果指定了第一个路径参数，则通过 req.path 获取到的是不包含该请求路径的字符串// 例如当前请求路劲是 /public/a.jpg 则通过 req.path 拿到的就是 a.jpg// /public/a/a.css a/a.css// 目前已知传递给了 static 方法一个绝对路径 c:/project/public// 假设目前请求是 /public/a/a.css 拿到的 req.path a/a.css// c:/project/public + a/a.css 拼接起来，读取app.use('/public', static(path.join(__dirname, 'public')))app.use('/node_modules', static(path.join(__dirname, 'node_modules')))app.get('/', (req, res, next) =&gt; &#123; console.log('/ 111') res.end('hello') next()&#125;)4 使用mongoose操作数据库的基本语法12345678910111213141516171819202122232425262728const mongoose = require('mongoose')mongoose.connect('mongodb://localhost/test')// 1. 创建一个模型架构，设计数据结构和约束const studentSchema = mongoose.Schema(&#123; name: String, age: Number&#125;)// 2. 通过 mongoose.model() 将架构发布为一个模型（可以把模型认为是一个构造函数）// 第一个参数就是给你的集合起一个名字，这个名字最好使用 帕斯卡命名法// 例如你的集合名 persons ，则这里就命名为 Person，但是最终 mongoose 会自动帮你把 Person 转为 persons// 第二个参数就是传递一个模型架构const Student = mongoose.model('Student', studentSchema)//3. 通过操作模型去操作你的数据库// 保存实例数据对象const s1 = new Student(&#123; name: 'Mike', age: 23&#125;)s1.save((err, result) =&gt; &#123; if (err) &#123; throw err &#125; console.log(result)&#125;)5 使用nunjucks模板引擎// 配置使用 nunjucks 模板引擎 // nunjucks 模板引擎没有对模板文件名的后缀名做特定限制 // 如果文件名是 a.html 则渲染的时候就需要传递 a.html // 如果文件名是 b.nujs 则传递 b.nujs // nunjucks 模板引擎默认会缓存输出过的文件 // 这里为了开发方便，所以把缓存禁用掉，可以实时的看到模板文件修改的变化 nunjucks.configure(config.viewPath, { autoescape: true, express: app, noCache: true }) 6 使用body-parser处理post请求 将其挂载在req.body上123456789101112131415161718192021222324// 如果是普通表单POST，则咱们自己处理 application/x-www-form-urlencoded// 如果是有文件的表单POST，则咱们不处理if( req.headers['content-type'].startsWith('multipart/form-data') ) &#123; return next()&#125;import queryString from 'querystring'export default (req, res, next) =&gt; &#123; // req.headers 可以拿到当前请求的请求报文头信息 if (!req.headers['content-length']) &#123; console.log('进入 body-parser 了') return next() &#125; let data = '' req.on('data', chunk =&gt; &#123; data += chunk &#125;) req.on('end', () =&gt; &#123; // 将查询字符串 转化为对象 req.body = queryString.parse(data) next() &#125;)&#125;7 使用formidable处理文件上传 比如说 图片这种1234567891011121314151617181920212223242526272829303132npm install --save formidableyarn add formidable const form = new formidable.IncomingForm() form.uploadDir = config.uploadDir // 配置 formidable 文件上传接收路径 form.keepExtensions = true // 配置保持文件原始的扩展名 form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; return next(err) &#125; const body = fields // 普通表单字段 body.image = basename(files.image.path) // 这里解析提取上传的文件名，保存到数据库 const advert = new Advert(&#123; title: body.title, image: body.image, link: body.link, start_time: body.start_time, end_time: body.end_time, &#125;) advert.save((err, result) =&gt; &#123; if (err) &#123; return next(err) &#125; res.json(&#123; err_code: 0 &#125;) &#125;) &#125;还有一种 就是 使用promise对象 处理回调函数1234567891011121314151617181920212223242526272829303132333435363738 pmFormidable(req) .then((result) =&gt; &#123; const [fields, files] = result const body = fields // 普通表单字段 body.image = basename(files.image.path) // 这里解析提取上传的文件名，保存到数据库 const advert = new Advert(&#123; title: body.title, image: body.image, link: body.link, start_time: body.start_time, end_time: body.end_time, &#125;) return advert.save() &#125;) .then(result =&gt; &#123; res.json(&#123; err_code: 0 &#125;) &#125;) .catch(err =&gt; &#123; next(err) &#125;) function pmFormidable(req) &#123; return new Promise((resolve, reject) =&gt; &#123; const form = new formidable.IncomingForm() form.uploadDir = config.uploadDir // 配置 formidable 文件上传接收路径 form.keepExtensions = true // 配置保持文件原始的扩展名 form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; reject(err) &#125; resolve([fields, files]) &#125;) &#125;) &#125;`同步分页 和 异步无刷新分页1234567891011121314151617181920212223242526272829//同步分页 这个是在服务器端 就进行分页 &#123; const page = Number.parseInt(req.query.page,10); const pageSize = 5; Advert .find() .skip((page - 1) * 5) .limit(10) .exec((err, adverts) =&gt; &#123; if (err) &#123; return next(err) &#125; // https://docs.mongodb.com/manual/reference/method/db.collection.count/ // 这个的api 又回到了 db.collection.count 这里的ccount 就是指的总条数 Advert.count((err,count)=&gt;&#123; if(err) &#123; return next(err) &#125; const totalPage = Math.ceil(count/pageSize); res.render('advert_list.html',&#123; adverts, totalPage, page &#125;) &#125;) &#125;) &#125;异步无刷新分页 使用的 twbs-pagination 插件123456789101112131415161718192021$.ajax(&#123; url: '/advert/count', type: 'get', success: function (data) &#123; if (data.err_code === 0) &#123; $('#pagination').twbsPagination(&#123; totalPages: Math.ceil(data.result / pageSize), visiblePages: 5, first: '首页', prev: '上一页', next: '下一页', last: '尾页', onPageClick: function (event, page) &#123; // 当你点击该页的时候 进行的行为 // 在这里我们要加载数据 loadData(page); &#125; &#125;) &#125; &#125;&#125;)用户登录状态的保持 cookie和session1234567891011121314151617 有一个cookie-parser插件 // 关于从 HTTP 协议角度使用 Cookie// 1. 通过响应报文在报文头中加入一个字段：Set-Cookie 值就是：key=value 的格式// 2. 当浏览器收到服务端响应回来的数据的时候，发现响应头中有一个 Set-Cookie // 然后浏览器会将该 Cookie 对应的数据保存起来（会话Cookie，持久化）// 3. 当下一次浏览器再次访问该服务器的时候，浏览器会自动将保存的所有 Cookie 放到请求报文头中都带上来// 4. 然后服务端就可以根据当前客户端的请求报文头中的 cookie 字段来获取进行判断// 引入express中处理cookie的中间件import cookieParser from 'cookie-parser'// 挂载 cookie-parser 中间件：专门用来处理对 cookie 的操作的// cookie-parser 中间件做两件事儿：// req.cookies 通过该中间件会自动将当前请求报文中的 cookie 解析为一个对象挂载到 req.cookies 属性上// res.cookie(name, value) 通过 res.cookie 可以向当前请求客户端发送 cookie 数据 // 这是设置app.use(cookieParser())手写session1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const sessionStorage = &#123;&#125;export default (options) =&gt; &#123; return (req, res, next) =&gt; &#123; const &#123; sidName &#125; = options // 当客户端请求过来的时候，先判断一下是否有 sessionid // 如果有，则直接跳过去 // 如果没有，则生成一把钥匙发送给用户 const sidCookie = req.cookies[sidName] // req.getSession = function () &#123; // !sessionStorage[sidCookie] &amp;&amp; (sessionStorage[sidCookie] = &#123;&#125;) // return sessionStorage[sidCookie] // &#125; // req.setSession = function (name, value) &#123; // console.log('setSession') // req.getSession()[name] = value // &#125; // 添加一个属性成员 req.session // 作用：用来根据当前请求客户端的 sessionid 对 Session 数据的取值和赋值 Object.defineProperty(req, 'session', &#123; get: function () &#123; !sessionStorage[sidCookie] &amp;&amp; (sessionStorage[sidCookie] = &#123;&#125;) return sessionStorage[sidCookie] &#125; &#125;) // 如果没有 sessionid ，则生成一个，发送给客户端 if (!sidCookie) &#123; res.cookie(sidName, generateSid()) return next() &#125; // 如果有 sessionid ，则直接跳过 next() &#125;&#125;function generateSid() &#123; return `it_$&#123;Math.random().toString().substr(2)&#125;cast$&#123;Math.random().toString().substr(2)&#125;`&#125;// export default (req, res, next) =&gt; &#123;// &#125;","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://majunchang.github.io/categories/Nodejs/"}],"tags":[]},{"title":"解析jquery的思想初步的封装final","slug":"解析jquery的思想初步的封装4","date":"2016-11-01T12:24:01.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"解析jquery的思想初步的封装4/","link":"","permalink":"https://majunchang.github.io/解析jquery的思想初步的封装4/","excerpt":"","text":"jq 案例&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt; ... 鼠标移入的时候有颜色高亮, 鼠标移开的时候颜色恢复$( ‘#dv’ ).mouseenter(function () {$( this ).addClass…}).mouseleave(function () {$( this ). …});123456789101112131415iQuery.select = function ( selector ) &#123; return slice.call( document.querySelectorAll( selector ) ); &#125;; //这里直接return document.querySelectorAll( selector)行吗？一定要返回一个真数组吗？ //构造函数中push.apply(this, iQuery.select(selector));传入伪数组也是可以的吧？var init = iQuery.prototype.init = function (selector) &#123; return [].push.apply(this, iQuery.select(selector)); &#125; iQuery.select = function (selector) &#123; return [].slice.call(document.querySelectorAll(selector)); &#125; 为什么要分成两步，直接[].push.apply(this,document.querySelectorAll(selector))不就好了，为什么[].slice.call(document.querySelectorAll(selector))转换成真数组再[].push.apply(this, iQuery.select(selector))核心结构中iQuery.fn = iQuery.prototype = {};iQuery.prototype.init.prototype = iQuery.fn;但是这两句连写成iQuery.prototype.init.prototype = iQuery.fn = iQuery.prototype = {};会报错Cannot set property ‘prototype’ of undefined。是因为赋值的先后顺序。疑问：iQuery.select = function(selector){slice.call(document.querySelectorAll(selector));}用来获取dom对象,var init = iQuery.fn.init = function(){push.apply(this,iQuery);}用来初始化函数,是不是多此一举?为什么不直接:var init = iQuery.fn.init = function(){slice.apply(this,document.querySelectorAll(selector));}","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://majunchang.github.io/categories/JQuery/"}],"tags":[]},{"title":"数组的去重和反转","slug":"数组中的那些事","date":"2016-10-10T15:32:47.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"数组中的那些事/","link":"","permalink":"https://majunchang.github.io/数组中的那些事/","excerpt":"","text":"数组的去重六种方法总结1 生成随机的彩票数字123456789101112131415161718192021222324252627// 彩票数的返回是从1到32 var numArr = []; for(var i=0;i&lt;6;i++) &#123; var num = Math.floor(Math.random()*31)+1; // 在数组添加这个元素之前 应该做一次去重判断 console.log(num); quchong(numArr,num); &#125; console.log(numArr.sort(function (a,b) &#123; return a-b; &#125;)); function quchong(arr,num) &#123; for(var j=0;j&lt;=arr.length;j++) &#123; console.log('liuyifei'); if(num === arr[j]) &#123; return false; &#125; arr.push(num); return false; // 出现死循环的原因： 当你添加一个元素的时候 数组的长度就会加1 // 这样num永远是第一次的num 这个内层的for循环也永远无法出去 故成为死讯话 &#125; &#125;2 在数组原型上添加方法 通过标志位来判断1234567891011121314Array.prototype.unique = function()&#123; var len = this.length, newArr = [], flag = 1; for(var i = 0; i &lt; len; i++, flag = 1)&#123; for(var j = 0; j &lt; i; j++)&#123; if(this[i] == this[j])&#123; flag = 0; //找到相同的数字后，不执行添加数据 &#125; &#125; flag ? newArr.push(this[i]) : ''; &#125; return newArr;&#125;3 使用es5的方法 即indexof 来进行判断 原理是 当数组不包含这个元素的时候 会返回-1123456789101112var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];Array.prototype.unique2 = function()&#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(this[i]) == -1) n.push(this[i]); &#125; return n;&#125;4 使用es6的方法 includes 原理是：当数组不包含这个元素的时候 返回false123456789101112var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];Array.prototype.unique = function () &#123; var newArr = []; for(var i=0;i&lt;this.length;i++) &#123; if(newArr.includes(this[i])===false) &#123; newArr.push(arr[i]) &#125; &#125; return newArr;&#125;5 使用es6的方法 set 原理是：基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。6 使用对象 进行数组的去重，原理是 对象的属性名 具有唯一性12345678910var obj = &#123;&#125;;var newArr = [];for(var i=0;i&lt;arr.length;i++)&#123; obj[arr[i]] = i;&#125;for(var k in obj)&#123; newArr.push(k);&#125;数组的反转 以及 交换两个变量的方法12345678910111213141516171819202122232425var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; Array.prototype.re = function () &#123; for (var i = 0; i &lt; this.length / 2; i++) &#123; // 交换两个变量的值 var temp = this[i];; this[i] = this[this.length - i - 1]; this[this.length - i - 1] = temp; &#125; console.log(this); return this; &#125; var newArr = arr.re(); console.log(newArr); var a =10; var b = 20; a=a^b; b=a^b; a=a^b; a=a+b; b=a-b; a=a-b; console.log(a); console.log(b);使用一个for循环完成数组的排序12345678var arr = [1,2,5,6,3,9,4,7,8,10]; var newArr = []; while (arr.length!=0)&#123; var item = Math.min.apply(arr,arr); arr.splice(arr.indexOf(item),1); newArr.push(item); &#125; console.log(newArr);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/categories/javascript/"}],"tags":[]},{"title":"解析jquery的思想初步的封装3","slug":"解析jquery的思想初步的封装3","date":"2016-10-10T01:10:48.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"解析jquery的思想初步的封装3/","link":"","permalink":"https://majunchang.github.io/解析jquery的思想初步的封装3/","excerpt":"","text":"对juqery核心结构的提炼以及封装完毕的map和each方法jq中的forEach和map方法 和 原生js中的有所不同，功能更加完善。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(function ( window ) &#123;var arr = [], push = arr.push, slice = arr.slice;var iQuery = function ( selector ) &#123; return new iQuery.fn.init( selector );&#125;iQuery.fn = iQuery.prototype = &#123; constructor: iQuery, each: function ( callback ) &#123; return iQuery.each( this, callback ); &#125;, map: function ( callback ) &#123; return iQuery.map( this, callback ); &#125;&#125;;// 将所有的方法应该挂载到 iQuery 中iQuery.select = function ( selector ) &#123; return slice.call( document.querySelectorAll( selector ) );&#125;;// 工具方法 each mapiQuery.each = function ( arr, callback ) &#123; var i; if ( arr.length &gt;= 0 ) &#123; for ( i = 0; i &lt; arr.length; i++ ) &#123; if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; &#125; &#125; else &#123; for ( i in arr ) &#123; if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; &#125; &#125; return arr;&#125;;iQuery.map = function ( arr, callback ) &#123; var rest = [], tmp, i; if ( arr.length &gt;= 0 ) &#123; for ( i = 0; i &lt; arr.length; i++ ) &#123; tmp = callback( arr[ i ], i ); if ( tmp != null ) &#123; rest.push( tmp ); &#125; &#125; &#125; else &#123; for ( i in arr ) &#123; tmp = callback( arr[ i ], i ); if ( tmp != null ) &#123; rest.push( tmp ); &#125; &#125; &#125; return rest;&#125;;// 扩展能力iQuery.extend = iQuery.fn.extend = function ( options ) &#123; for ( var k in options ) &#123; this[ k ] = options[ k ]; &#125;&#125;;window.iQuery = window.I = iQuery;&#125;)( window );框架的 扩展所谓的扩展就是给原型或构造方法( iQuery ) 提供新的成员就是在给一个对象增加新的成员可以使用混合式. 其思想就是将几个对象的成员混合到一起extend 扩展123456789101112131415161718// 对原型的处理iQuery.fn.extend = function ( options ) &#123; for ( var k in options ) &#123; this[ k ] = options[ k ]; &#125;&#125;// 对 iQuery 处理iQuery.extend = function( options ) &#123; for ( var k in options ) &#123; this[ k ] = options[ k ]; &#125;&#125; iQuery.extend = iQuery.fn.extend = function ( options ) &#123; for ( var k in options ) &#123; this[ k ] = options[ k ]; &#125;&#125;;将来在扩展功能的时候怎么用呢?1) 扩展实例方法iQuery.fn.extend({method: function …});2) 扩展静态方法iQuery.extend( … )##. DOM 操作appendToappendprependToprependinsertBeforeinsertAfterbeforeparentnextnextAllprevprevAllsiblingsparseHTML产生了一个问题所有的 dom 元素只允许有一个父元素. 因此将一个 dom 元素追加到另一个元素里时, 会自动的从原有的父元素中移除.&lt;div&gt;123&lt;/div&gt; &lt;div&gt;456&lt;/div&gt; 将 第 0 个 div 追加到 body 上的时候, 会从原有的位置移除&lt;div&gt;456&lt;/div&gt; 此时 childNodes 的长度也会自动的 -1, 原来排在第 1 号位置的 div 也会变成 第 0 号.将构造函数进一步的完善修改构造函数, 判断一下, 如果是 字符串结构, 就采用 parseHTML如果不是字符串结构就用 qsa 方法在 jq 构造函数中, 参数可以是很多东西 1) 字符串: 1&gt;选择器, 2&gt;HTML 字符串 2) DOM 元素 3) 函数: 相当于 onload 事件 4) jquery 元素 $( &apos;&lt;div /&gt;&apos; ).appendTo( $( &apos;body&apos; ) ); $( &apos;&lt;div /&gt;&apos; ).appendTo( &apos;body&apos; ); 5) 可以是 空 ... 在 init 构造函数中准备一套 if else 结构 处理每一个情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var init = iQuery.fn.init = function ( selector ) &#123; // 处理: I( '' ), I( null ), I( undefiend ) 等 if ( !selector ) return this; // 处理: 字符串 if ( typeof selector == 'string' ) &#123; // 处理多种 // \\s*&lt;.+&gt;\\s* if ( rquickExpr.test( selector ) ) &#123; // HTML 格式的字符串 push.apply( this, iQuery.parseHTML( selector ) ); &#125; else &#123; // 选择器字符串 push.apply( this, iQuery.select( selector ) ); &#125; return this; &#125; // 处理函数 if ( typeof selector == 'function' ) &#123; &#125; // 处理 DOM 元素 if ( selector.nodeType ) &#123; this[ 0 ] = selector; this.length = 1; return this; &#125; // 处理 iQuery 对象 if ( selector.type === 'iQuery' ) &#123; // return selector; // 推荐的处理办法是将 selector 中的所有元素加到 this 中 push.apply( this, selector ); return this; &#125; if ( selector.length &gt;= 0 ) &#123; push.apply( this, selector ); &#125; else &#123; this[ 0 ] = selector; this.length = 1; &#125; return this;&#125;;init.prototype = iQuery.fn;","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://majunchang.github.io/categories/JQuery/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://majunchang.github.io/tags/JQuery/"}]},{"title":"解析jquery的思想初步的封装2","slug":"解析jquery的思想初步的封装2","date":"2016-09-25T13:24:02.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"解析jquery的思想初步的封装2/","link":"","permalink":"https://majunchang.github.io/解析jquery的思想初步的封装2/","excerpt":"","text":"1. 自己封装一个函数完成数组遍历, 要求模拟数组的 forEach 方法1.函数中如果没有代码 数组的每一项就什么也不做2.函数中写什么代码 数组中的每一项就做什么事情3.也就是说函数在处理数组的每一项由于要处理每一项, 因此必须要遍历数组的每一个元素使用函数处理每一项就是用函数处理 item. 就是说将 item 传入函数处理123456function each( arr, callback ) &#123; for ( var i= 0; i &lt; arr.length; i++ ) &#123; var item = arr[ i ]; callback( item ); &#125; &#125;按照 数组的 forEach 方法实现 自己的 each 方法要求 有两个参数, 一个是需要遍历的数组, 一个是回调函数, 要求回调函数有两个参数, 分别是 v, i12345function each( arr, callback ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; callback( arr[ i ], i ); &#125; &#125;改良第一步, 添加 this 的引用, 参数向 jq 靠拢12345function each( arr, callback ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; callback.call( arr[ i ], i, arr[ i ] ); &#125; &#125;第二次改良, 在返回 false 的时候跳出循环, 注意, 返回 undefined, 0, 等不会跳出所以这里一定有一个完全等于, 跳出循环就是跳出 each 函数内的 for 即需要 break12345function each( arr, callback ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; &#125; &#125;第三个改良就是返回被遍历的对象123456function each( arr, callback ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; &#125; return arr; &#125;遍历对象与遍历数组 有什么区别?遍历对象是将对象的所有键值对遍历出来( 包括自然数项, 如果有的话 )遍历数组就是在遍历自然数项判断数组或伪数组的依据就是 length &gt;= 0123456789101112function each( arr, callback ) &#123; if ( arr.length &gt;= 0 ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; if ( callback.call( arr[ i ], i, arr[ i ] ) === false ) break; &#125; &#125; else &#123; for ( var k in arr ) &#123; if ( callback.call( arr[ k ], k, arr[ k ] ) === false ) break; &#125; &#125; return arr;&#125;2 封装 map首先考虑, 只是处理 v 返回 结果( 实现一个 与 数组 的 map 一样的方法 )function map( arr, callback ) {var rest = [];for ( var i = 0; i &lt; arr.length; i++ ) {// 要返回的数据是 回调函数的 返回值rest.push( callback( arr[ i ], i ) );}return rest;}// 向 jq 靠拢// 1&gt; 不返回则不加到数组中// 2&gt; 遍历对象12345678910111213141516171819function map( arr, callback ) &#123; var rest = [], tmp; if ( arr.length &gt;= 0 ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; tmp = callback( arr[ i ], i ); if ( tmp != null ) &#123; rest.push( tmp ); &#125; &#125; &#125; else &#123; for ( var k in arr ) &#123; tmp = callback( arr[ k ], k ); if ( tmp != null ) &#123; rest.push( tmp ); &#125; &#125; &#125; return rest;&#125;3. 框架的核心结构需求:1&gt; 有一个函数, 可以实现元素的获取功能( select -&gt; Array )2&gt; 这个函数返回的对象具有 each 方法. 该方法只有一个 回调函数的参数, 用于遍历每一个对象.先把函数写出来function I( selector ) {} 该函数可以获取元素function I( selector ) {var list = document.querySelectorAll( selector ); // 伪数组}返回的数据应该就是这个 list, 但是又需要有 each所以可以考虑直接让 list 带有 each 方法123456789function I( selector ) &#123; var list = document.querySelectorAll( selector ); // 伪数组 list.each = function ( callback ) &#123; // 调用 该方法就是在 遍历 list 并将每一个元素用 callback 进行处理 each( this, callback ); &#125; return list&#125;4.引入构造函数( init )知道 list 是一个有 qsa 方法返回的对象, 每次提供 each 方法不合理, 而且 jq 有很多方法所以借助 oop 的知识应该使用 继承. 利用构造函数来创建 “list 对象”, 但是继承自提供each 等方法的原型对象.123456function F( selector ) &#123; // 给 this 加 伪数组项&#125;F.prototype.each = function () &#123;&#125;考虑到 list 中每次都添加方法不合理, 而且冗余, 因此使用构造函数创建对象( 伪数组 ).让构造函数.prototype 提供各种方法, 那么实例对象( 伪数组 )就可以使用这些方法了.1234567891011121314151617181920212223function F( selector ) &#123; // 给 this 加 伪数组项 var list = document.querySelectorAll( selector ); for( var i = 0; i &lt; list.length; i++ ) &#123; this[ i ] = list[ i ]; &#125; this.length = list.length;&#125;F.prototype.each = function ( callback ) &#123; each( this, callback );&#125;;升级一下function F( selector ) &#123; // 给 this 加 伪数组项 [].push.apply( this, document.querySelectorAll( selector ) );&#125;F.prototype.each = function ( callback ) &#123; each( this, callback );&#125;;如何使用呢?new F( 'div, p' ).each( ... )5.隐藏 new 关键字考虑引入函数function iQuery( selector ) {return new F( selector ); }var I = iQuery;引入沙箱从沙箱中如果要暴露一些函数或对象采用方法有三种( 常用 )1&gt; 利用 window 参数(function ( window ) { window.xxx = vvv; })( window ); 2&gt; 利用 返回值( 例如 Sizzle )var Sizzle = (function () { return xxx; })(); 3&gt; 利用 this 映射(function () { this.xxx = vvv; })(); 缺点:1&gt; 代码结构凌乱. 优化结构.2&gt; 无法实现扩展, 只有在该文件中实现代码结构.6. 可扩展性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071721&gt; 可以将 iQuery 的一个属性指向构造函数 var iQuery = function ( selector ) &#123; return new F( selector ); &#125;; ... iQuery.F = F; ... 此时对外的扩展 iQuery.F.prototype.xxx = vvv;2&gt; 在 jq 中采用是原型映射的办法, jq 中将 对外公开的 jquery 函数 与 构造函数 的原型用一个对象表示 // 类比 F.prototype = &#123;&#125;; iQuery.prototype = F.prototype; //=============================================================== var jQuery = function ( selector ) &#123; return ...( selector ); &#125;; jQuery.prototype = &#123; // 对象 constructor: jQuery, each: function () .... &#125;; var init = function ( selector ) &#123; // ... 构造函数 ... // [].push.apply( this, document.querySelectorAll( selector ) ); &#125;; init.prototype = jQuery.prototype; //=============================================================== // 在 jq 中又 进一步处理 // 将 init 函数作为 jquery 的原型的一个方法 // 将所有的方法挂载到 jQuery 上, 便于优化与更新 // jquery 1.7 以后的写法 var jQuery = function ( selector ) &#123; return new jQuery.fn.init( selector ); &#125;; jQuery.fn = jQuery.prototype = &#123; // 对象 constructor: jQuery &#125;; var init = jQuery.fn.init = function ( selector ) &#123; // ... &#125;; init.prototype = jQuery.fn; 等价的写法 // jquery 1.7 以前的写法 var jQuery = function ( selector ) &#123; return new jQuery.fn.init( selector ); &#125;; jQuery.fn = jQuery.prototype = &#123; // 对象 constructor: jQuery, init: function ( selector ) &#123; // ... &#125; &#125;; jQuery.fn.init.prototype = jQuery.fn;","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://majunchang.github.io/categories/JQuery/"}],"tags":[]},{"title":"对于jquery思想的理解初步的封装1","slug":"解析jquery的思想初步的封装1","date":"2016-09-19T23:50:11.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"解析jquery的思想初步的封装1/","link":"","permalink":"https://majunchang.github.io/解析jquery的思想初步的封装1/","excerpt":"","text":"本篇博客主要研究一下几个分类-&gt; 选择模块-&gt; 框架的核心结构-&gt; DOM 操作-&gt; 事件与属性和样式-&gt; 插件机制-&gt; 工具引入问题将下列 div 与 p 标签添加 1px solid red 样式12345678910111213141516171819&lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;P&lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;P&lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;P&lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt; &lt;p&gt;P&lt;/p&gt; &lt;span&gt;span&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;span&gt;span&lt;/span&gt;DOM 操作的要求和DOM 常用属性学会分析 DOM 树绘制 DOM 树( 标准 代码需要与图对象 ) 增删改查的方法查: document.getElementById() document.getElementsByTagName() document.getELementsByClassName() document.getElementsByName() document.querySelector() document.querySelectorAll() 访问亲属节点深度为 2 级如何访问父节点 如果访问兄弟节点 如何访问子节点 DOM常用属性：.nodeName 标签名, 都是大写.nodeType 获得节点的类型: 1, 元素; 2, 属性; 3, 文本.nodeValue 常常用于文本节点, 表示文本的内容详解几个知识点：jq中会使用到的-&gt; NodeList该数据就是一个伪数组的数据类型 HTMLCollection NodeList 用于描述一个集合数据类型( 伪数组 ) 123456789101112131415问 [].slice.call Array.prototype.slice.call rest.slice.call 有什么区别?var o = &#123; method: function () &#123;&#125;&#125;;o.method();o.method.call( ... )var f = o.method;f.call( ... );apply call 参数1. 概念 [].push.apply( rest, list ); 相当于 rest.push( &quot;list&quot; ) [].push.call( rest, list ); 相当于 rest.push( &quot;list&quot; ) 2. call 与 apply 的参数 第一个参数: 如果是基本类型( string, number, boolean ) 会转换成包装类型( String, Number, Boolean ) 如果是引用类型( 非空 ), this 就是它( 相当于方法调用 ) 如果是空( null 与 undefined ) 那么 this 就是 window 第二个+参数 apply 只有两个参数, 第二个参数一定是一个数组( 伪数组 ) func.apply( obj, [ a, b, c, ..., n ] ) 等价于 func( a, b, c, ..., n ) call 将参数散列处理, 函数调用时怎么传参, call 就怎么传参 func.call( obj, a, b, c, ..., n ) 等价于 func( a, b, c, ..., n ) 3. 既然有 call 为何还要有 apply 12345678910111213var arr = [ 1, 2 ];arr.push( 3, 4, 5, 6, 7 );var weiArray = &#123; 0:1, 1:2, 2:3, length: 3 &#125;;var zhenArray = [ 1, 2 ];[].push.call( zhenArray, weiArray );=&gt;zhenArray.push( weiArray );[].push.apply( zhenArray, weiArray );=&gt;zhenArray.push( ...weiArray ) 关联数组的用法1234567891011121314151617var o = &#123; name:&apos;jim&apos;, age: 19, gender: &apos;男&apos; &#125;;// 点语法访问( 硬编码 )// o.name// 如果想要提供一个功能, 用户输入什么就访问什么if ( input === &apos;name&apos; ) &#123; o.name ....&#125;else if ( input === &apos;age&apos; ) &#123; o.age ....&#125;else if ( input === &apos;gender&apos; ) &#123; o.gender ....&#125;......// js 允许像使用数组一样使用对象, 只需要提供 属性的名字即可 // o[ 名字 ] o[ input ] =&gt; o[ &apos;name&apos; ] o[ &apos;age&apos; ] o[ &apos;gender&apos; ] ... ... 扩展DOM-Core 与 HTML DOM在 实际开发中, 有很多数据使用 XML 格式来进行表示的( win 新的技术( WPF ), 安卓界面, 苹果的界面, … )在处理这数据的时候 通用方法称为 核心 DOM 方法&lt;div&gt;111&lt;/div&gt;&lt;div&gt;2&lt;div&gt;111&lt;/div&gt;2&lt;div&gt;111&lt;/div&gt;2&lt;/div&gt;在实际应用 HTML 飞速发展, 因此在处理 HTML 的时候给出了一些快速处理的 api, 这些 api 就称为 HTML-DOMHTML-DOM, 首先是 DOM 方法, 适用于 HTML 文档给 body 标签增加一个 itcast 属性思考题:为什么 forEach 中的回调函数有第三个参数jq 中 map 与 each 中回调函数的参数为什么不同","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://majunchang.github.io/categories/JQuery/"}],"tags":[]},{"title":"深入浅出nodejs01","slug":"深入浅出nodejs01","date":"2016-09-10T15:16:02.000Z","updated":"2018-10-23T12:49:01.000Z","comments":true,"path":"深入浅出nodejs01/","link":"","permalink":"https://majunchang.github.io/深入浅出nodejs01/","excerpt":"","text":"深入浅出nodejsnode概要Node流行框架AngularJSVueJSGitGulpNpmBowerWebpack博学谷在线教育项目Node.js 介绍1.1 网站开发模型（BS）Server为客户端提交接口：数据Java、.Net、Ruby、Python、PHP、Go、Swift、Lua学 Node 本质不是在学 Node，在学 服务器（Web后台）编程请求处理响应大前端时代：JavaScript 语言也可以运行在服务器端使用 JavaScript 这门语言也可以进行服务器编程JavaScript 通过 Node.js 运行在服务器端Browser客户端：把一坨用户看不懂的数据变成友好的形式给用户体验1.2 什么是 Node.js？简单的说 Node.js 就是运行在服务端的 JavaScriptNode开发就是利用 Ecmascript + 第三方开源库 + Node平台环境API进行编程什么是 JavaScriptJavaScript 一个运行在浏览器端的脚本原因运行时：浏览器Ecmascript：JavaScript 基本语法：var、if-else、for、Array、Object、String、functionBOMWindowDOM渲染引擎JavaScript 解析执行引擎在所有浏览器中，Google Chrome 的 V8 引擎是最快的 JS 脚本代码解析执行引擎通过 V8 引擎解析和执行 JavaScript 代码Node 官网：https://nodejs.org/en/Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.Node.js 是一个构建与 Chrome V8 引擎之上的一个 JavaScript 运行时（执行环境）Node 使用 JavaScript 进行编程Node 采用了 Chrome 的 V8 引擎解析和执行 JavaScript 脚本代码Node 不是一种语言，Node 可以用来解析和执行 JavaScript 代码在 Node 没有 DOM、BOM 了，也不用去关心样式、结构问题了Node 在基本的 JavaScript 语言之上，或者在 Node 平台给 Ecmascript 提供了大量的底层编程接口例如文件IO例如网络IO处理数据操作数据库构建网络服务。。。Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.event-driven：事件驱动在 Node 中，也采用了类似于浏览器端的编程思想，事件模型编程思想non-blocking I/O model：非阻塞IO模型Node 中大量的通过类似于浏览器中 ajax 的方式进行编程绝大多数代码都是异步编程模型lightweight &amp; efficient：轻量和高效Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.Node.js 包生态系统 Npm 是世界上最大的开源库生态系统largest ecosystem：最大的开源库生态系统1.3 使用 Node 可以做什么？开发网站服务器游戏服务器开发命令行工具软件分为两种：GUI：看得见，鼠标点点点CLI：命令窗口，各种命令，选项参数等1.4 Node 发展史Node.js 由 Ryan Dahl 和一些其他的开发者于2009年在 Joyent 工作时发明Node 作者当初只是想做一个类似于 Apache 的服务器而已，最初的时候起的名字叫：webjs2009年2月，Ryan Dahl在博客上宣布准备基于V8创建一个轻量级的Web服务器并提供一套库。2009年5月，Ryan Dahl在GitHub上发布了最初版本的部分Node.js包，随后几个月里，有人开始使用Node.js开发应用。2009年11月和2010年4月，两届JSConf大会都安排了Node.js的讲座。2010年年底，Node.js获得云计算服务商Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js的发展。2011年7月，Node.js在微软的支持下发布Windows版本。[2]1.5 学习资源推荐国内NodeJS开发者社区：https://cnodejs.org/《深入浅出Node.js》：作者：阿里巴巴.朴灵快速上手2.1 环境安装https://nodejs.org/en/download/2.2 Hello World当你在控制台输入：node 01-hello-world.js 之后实际上通过你安装目录下的那个 node.exe 可执行程序读取了 01-hello-world.js 文件中的源代码然后解析和执行文件中的代码最后将结果打印输出到了控制台中2.3 path 环境变量目的：就是为了在终端的任意目录中都可以找到该可执行文件配置方式：一种在 path 中写路径，通过英文分号分隔一种先定义变量，给一个变量值，然后在 path 中通过英文分号进行分隔，使用 %变量名% 引用该变量2.4 文件操作2.5 HTTP 服务2.6 文件版留言本Node 基础3.1 Node 中的 JavaScriptconsolesetInterval(callback, delay[, …args])setTimeout(callback, delay[, …args])clearInterval(intervalObject)clearTimeout(timeoutObject)clearImmediate(immediateObject)setImmediate(callback[, …args])__dirname__filenamemoduleexportsglobalprocessrequire()3.2 模块化3.3 自定义模块（用户自己编写的模块）requiremodule.exportsexports3.4 核心模块（Node 提供）在线文档地址：https://nodejs.org/dist/latest-v6.x/docs/api/以下是常用的核心模块及作用：核心模块名 作用fs 文件操作http 网络操作net 更底层的网络操作os 操作系统相关path 文件路径操作querystring 查询字符串处理url url操作处理NodeNode 是一个平台，Node 是一个框架，基于 Ecmascript 语言，在这个平台（或者说框架）之上给 Ecmascript 提供了很多操作系统级别的编程接口。做 Node 编程实际上就是通过 Ecmascript、Node平台内置的核心模块、第三方社区提供的模块构建高度模块化的程序。REPL：Node 中类似于浏览器中的 Console 控制台ReadEvalPrintLoopNode 中的 JavaScriptEcmascriptconsolesetInterval(callback, delay[, …args])setTimeout(callback, delay[, …args])clearInterval(intervalObject)clearTimeout(timeoutObject)clearImmediate(immediateObject)setImmediate(callback[, …args])__dirname用于获取当前文件所属目录的绝对路径使用场景：常用语将相对路径转为绝对路径，防止执行node命令所处的目录影响路径的问题__filename作用：获取当前文件的绝对路径processprocess 是Node中一个进程对象，可以用来访问当前运行进程的一些信息global类似于浏览器中的 window，是一个全局对象唯一的区别在于浏览器中的 window 是全局对象，默认在全局声明的变量成员都属于 windowNode 中是模块作用域在一个模块系统中，所有的模块都共享一个 global也就是说可以通过给 global 显示的挂载成员在多个模块之间全局共享虽然可以这样做，了解即可，尽量不要使用模块成员modulemodule 是一个模块对象，里面包含了当前模块的一些信息例如 exports 就是当前模块对外的导出接口对象exports在每一个模块中，同时还提供了一个接口成员：exportsexports 是 module.exports 接口对象的一个引用也就是可以把 module.exports.foo=xxx 的形式简写为 exports.foo=xxx注意：注重向外的暴露的接口对象是：module.exportsrequire()执行被加载模块中的代码拿到被加载模块中的 module.exports 接口对象模块化模块化概念开发生产效率高可维护性好每一个模块默认都是一个私有的作用域，互相独立，内部实现某一个具体的功能职责，暴露接口成员，通过特定的规则将不同的模块组织到一起，就构成了一个完整的模块系统。自定义模块核心模块以下是Node中的一些核心模块及作用：核心模块名 作用fs 文件操作http 网络操作net 更底层的网络操作os 操作系统相关path 文件路径操作querystring 查询字符串处理url url操作处理第三方模块模块加载机制规则require 方法中传递的参数叫做模块标识，其中涉及三种情况：以 ./ 后者 ../ 或者 / 或者 C:/demo/a.js 这种形式的文件模块加载核心模块核心模块是Node内置的，例如：fs、http、url 等已经别编译到了可执行文件中了用的时候，必须通过一个特定的核心模块标识名称加载使用加载第三方模块通过 npm 下载的模块或者说包加载第三方模块也是通过指定第三方模块的标识名称加载的Node 会判定如果不是文件路径形式的模块，也不是核心模块Node 会基于当前文件模块同级目录中的 node_modules 目录去查找该第三方模块标识对应的目录如果在 node_modules 目录中能找到对应的目录，例如 mime则 Node 去 mime 目录下找 package.json 文件如果找到 package.json 文件，则找该文件中的 main 属性，然后根据该属性指向的文件模块进行加载如果上述条件某一个环节不成立，则 Node 进入上一级目录中的 node_modules 进行查找，规则同上如果一直到当前文件模块所属的磁盘根目录下都没有找到对应的 node_modules 中的第三方模块则最后报错：can not find module xxx包与Npm将一些相关功能的文件模块组织到一起就形成了一个包。使用 Npm 安装全局命令行工具在 npm 社区中，除了有可以在项目中使用的第三方包之外，还有一些特殊的包：这些特殊的包被称之为命令行工具，不是用于项目的，而是可以安装到计算机中，然后通过命令行中的命令的形式来使用，这种工具有很多，例如：http-server、gulp、browser-sync、nodemon 等等等等很多。安装方式：npm install --global 第三方命令行工具名字 卸载：npm uninstall --global 第三方命令行工具名称 查看全局命令行安装目录：npm root --global","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://majunchang.github.io/categories/Nodejs/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://majunchang.github.io/tags/javascript/"}]}]}